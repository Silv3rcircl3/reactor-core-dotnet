using Reactive.Streams;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Reactor.Core.publisher;
using Reactor.Core.subscriber;
using Reactor.Core.flow;
using Reactor.Core.scheduler;
using Reactor.Core.util;
using System.Threading.Tasks;
using System.Threading;

namespace Reactor.Core
{
    /// <summary>
    /// Extension methods for IFlux sources.
    /// </summary>
    public static class Flux
    {
        /// <summary>
        /// The default buffer size and prefetch amount.
        /// </summary>
        public static int BufferSize { get { return 128; } }

        // ---------------------------------------------------------------------------------------------------------
        // Enter the reactive world
        // ---------------------------------------------------------------------------------------------------------


        /// <summary>
        /// Create a new IPublisher that will only emit the passed data then onComplete.
        /// </summary>
        /// <typeparam name="T">The value type</typeparam>
        /// <param name="value">The unique data to emit</param>
        /// <returns>The new IPublisher instance</returns>
        public static IFlux<T> Just<T>(T value)
        {
            return new PublisherJust<T>(value);
        }

        /// <summary>
        /// Returns an empty instance which completes the ISubscribers immediately.
        /// </summary>
        /// <typeparam name="T">The value type</typeparam>
        /// <returns>The shared Empty instance.</returns>
        public static IFlux<T> Empty<T>()
        {
            return PublisherEmpty<T>.Instance;
        }

        /// <summary>
        /// Returns an never instance which sets an empty ISubscription and
        /// does nothing further.
        /// </summary>
        /// <typeparam name="T">The value type</typeparam>
        /// <returns>The shared Never instance.</returns>
        public static IFlux<T> Never<T>()
        {
            return PublisherNever<T>.Instance;
        }

        /// <summary>
        /// Build a IFlux whose data are generated by the combination of the most recent published values from all
        /// publishers.
        /// </summary>
        /// <remarks>
        /// Marble diagram:
        /// https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/combinelatest.png
        /// </remarks>
        /// <typeparam name="T">The input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="combiner">The function that will receive the latest values from all sources and has to produce an output value.</param>
        /// <param name="delayError">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <param name="sources">The input IPublisher sources.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> CombineLatest<T, R>(Func<T[], R> combiner, bool delayError = false, params IPublisher<T>[] sources)
        {
            return CombineLatest(combiner, BufferSize, delayError, sources);
        }

        /// <summary>
        /// Build a IFlux whose data are generated by the combination of the most recent published values from all
        /// publishers.
        /// </summary>
        /// <remarks>
        /// Marble diagram:
        /// https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/combinelatest.png
        /// </remarks>
        /// <typeparam name="T">The input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="combiner">The function that will receive the latest values from all sources and has to produce an output value.</param>
        /// <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <param name="delayError">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <param name="sources">The input IPublisher sources.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> CombineLatest<T, R>(Func<T[], R> combiner, int prefetch, bool delayError = false, params IPublisher<T>[] sources)
        {
            return new PublisherCombineLatest<T, R>(sources, null, prefetch, delayError, combiner);
        }

        /// <summary>
        /// Boxes or casts a value to object.
        /// </summary>
        /// <typeparam name="T">The input value type</typeparam>
        /// <param name="source">The source IPublisher</param>
        /// <returns>The IFlux instance.</returns>
        static IFlux<object> Box<T>(IPublisher<T> source)
        {
            return new PublisherMap<T, object>(source, v => (object)v);
        }

        /// <summary>
        /// Build a IFlux whose data are generated by the combination of the most recent published values from all
        /// publishers.
        /// </summary>
        /// <remarks>
        /// Marble diagram:
        /// https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/combinelatest.png
        /// </remarks>
        /// <typeparam name="T1">The first source's value type.</typeparam>
        /// <typeparam name="T2">The second source's value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="combiner">The function that will receive the latest values from all sources and has to produce an output value.</param>
        /// <param name="delayError">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <param name="p1">The first source.</param>
        /// <param name="p2">The second source.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> CombineLatest<T1, T2, R>(IPublisher<T1> p1, IPublisher<T2> p2, Func<T1, T2, R> combiner, bool delayError = false)
        {
            return CombineLatest<object, R>(a =>
                {
                    return combiner((T1)a[0], (T2)a[1]);
                }, 
                BufferSize, delayError, 
                Box(p1), Box(p2)
            );
        }

        /// <summary>
        /// Build a IFlux whose data are generated by the combination of the most recent published values from all
        /// publishers.
        /// </summary>
        /// <remarks>
        /// Marble diagram:
        /// https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/combinelatest.png
        /// </remarks>
        /// <typeparam name="T1">The first source's value type.</typeparam>
        /// <typeparam name="T2">The second source's value type.</typeparam>
        /// <typeparam name="T3">The third source's value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="combiner">The function that will receive the latest values from all sources and has to produce an output value.</param>
        /// <param name="delayError">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <param name="p1">The first source.</param>
        /// <param name="p2">The second source.</param>
        /// <param name="p3">The third source.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> CombineLatest<T1, T2, T3, R>(
            IPublisher<T1> p1, IPublisher<T2> p2,
            IPublisher<T3> p3,
            Func<T1, T2, T3, R> combiner, bool delayError = false)
        {
            return CombineLatest<object, R>(a =>
            {
                return combiner((T1)a[0], (T2)a[1], (T3)a[2]);
            },
                BufferSize, delayError,
                Box(p1), Box(p2), Box(p3)
            );
        }

        /// <summary>
        /// Build a IFlux whose data are generated by the combination of the most recent published values from all
        /// publishers.
        /// </summary>
        /// <remarks>
        /// Marble diagram:
        /// https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/combinelatest.png
        /// </remarks>
        /// <typeparam name="T1">The first source's value type.</typeparam>
        /// <typeparam name="T2">The second source's value type.</typeparam>
        /// <typeparam name="T3">The third source's value type.</typeparam>
        /// <typeparam name="T4">The fourth source's value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="combiner">The function that will receive the latest values from all sources and has to produce an output value.</param>
        /// <param name="delayError">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <param name="p1">The first source.</param>
        /// <param name="p2">The second source.</param>
        /// <param name="p3">The third source.</param>
        /// <param name="p4">The fourth source.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> CombineLatest<T1, T2, T3, T4, R>(
            IPublisher<T1> p1, IPublisher<T2> p2,
            IPublisher<T3> p3, IPublisher<T4> p4,
            Func<T1, T2, T3, T4, R> combiner, bool delayError = false)
        {
            return CombineLatest<object, R>(a =>
            {
                return combiner((T1)a[0], (T2)a[1], (T3)a[2], (T4)a[3]);
            },
                BufferSize, delayError,
                Box(p1), Box(p2), Box(p3), Box(p4)
            );
        }

        /// <summary>
        /// Build a IFlux whose data are generated by the combination of the most recent published values from all
        /// publishers.
        /// </summary>
        /// <remarks>
        /// Marble diagram:
        /// https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/combinelatest.png
        /// </remarks>
        /// <typeparam name="T1">The first source's value type.</typeparam>
        /// <typeparam name="T2">The second source's value type.</typeparam>
        /// <typeparam name="T3">The third source's value type.</typeparam>
        /// <typeparam name="T4">The fourth source's value type.</typeparam>
        /// <typeparam name="T5">The fifth source's value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="combiner">The function that will receive the latest values from all sources and has to produce an output value.</param>
        /// <param name="delayError">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <param name="p1">The first source.</param>
        /// <param name="p2">The second source.</param>
        /// <param name="p3">The third source.</param>
        /// <param name="p4">The fourth source.</param>
        /// <param name="p5">The fifth source.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> CombineLatest<T1, T2, T3, T4, T5, R>(
            IPublisher<T1> p1, IPublisher<T2> p2,
            IPublisher<T3> p3, IPublisher<T4> p4,
            IPublisher<T5> p5,
            Func<T1, T2, T3, T4, T5, R> combiner, bool delayError = false)
        {
            return CombineLatest<object, R>(a =>
            {
                return combiner((T1)a[0], (T2)a[1], (T3)a[2], (T4)a[3], (T5)a[4]);
            },
                BufferSize, delayError,
                Box(p1), Box(p2), Box(p3), Box(p4), Box(p5)
            );
        }

        /// <summary>
        /// Build a IFlux whose data are generated by the combination of the most recent published values from all
        /// publishers.
        /// </summary>
        /// <remarks>
        /// Marble diagram:
        /// https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/combinelatest.png
        /// </remarks>
        /// <typeparam name="T1">The first source's value type.</typeparam>
        /// <typeparam name="T2">The second source's value type.</typeparam>
        /// <typeparam name="T3">The third source's value type.</typeparam>
        /// <typeparam name="T4">The fourth source's value type.</typeparam>
        /// <typeparam name="T5">The fifth source's value type.</typeparam>
        /// <typeparam name="T6">The sixth source's value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="combiner">The function that will receive the latest values from all sources and has to produce an output value.</param>
        /// <param name="delayError">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <param name="p1">The first source.</param>
        /// <param name="p2">The second source.</param>
        /// <param name="p3">The third source.</param>
        /// <param name="p4">The fourth source.</param>
        /// <param name="p5">The fifth source.</param>
        /// <param name="p6">The sixth source.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> CombineLatest<T1, T2, T3, T4, T5, T6, R>(
            IPublisher<T1> p1, IPublisher<T2> p2,
            IPublisher<T3> p3, IPublisher<T4> p4,
            IPublisher<T5> p5, IPublisher<T6> p6,
            Func<T1, T2, T3, T4, T5, T6, R> combiner, bool delayError = false)
        {
            return CombineLatest<object, R>(a =>
            {
                return combiner((T1)a[0], (T2)a[1], (T3)a[2], (T4)a[3], (T5)a[4], (T6)a[5]);
            },
                BufferSize, delayError,
                Box(p1), Box(p2), Box(p3), Box(p4), Box(p5), Box(p6)
            );
        }

        /// <summary>
        /// Build a IFlux whose data are generated by the combination of the most recent published values from all
        /// publishers.
        /// </summary>
        /// <remarks>
        /// Marble diagram:
        /// https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/combinelatest.png
        /// </remarks>
        /// <typeparam name="T">The input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="combiner">The function that will receive the latest values from all sources and has to produce an output value.</param>
        /// <param name="delayError">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <param name="sources">The input IPublisher sources.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> CombineLatest<T, R>(IEnumerable<IPublisher<T>> sources, Func<T[], R> combiner, bool delayError = false)
        {
            return CombineLatest(sources, combiner, BufferSize);
        }

        /// <summary>
        /// Build a IFlux whose data are generated by the combination of the most recent published values from all
        /// publishers.
        /// </summary>
        /// <remarks>
        /// Marble diagram:
        /// https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/combinelatest.png
        /// </remarks>
        /// <typeparam name="T">The input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="combiner">The function that will receive the latest values from all sources and has to produce an output value.</param>
        /// <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <param name="delayError">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <param name="sources">The input IPublisher sources.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> CombineLatest<T, R>(IEnumerable<IPublisher<T>> sources, Func<T[], R> combiner, int prefetch, bool delayError = false)
        {
            return new PublisherCombineLatest<T, R>(null, sources, prefetch, delayError, combiner);
        }

        /// <summary>
        /// Concatenates an IEnumerable sequence of IPublisher sources, optionally delaying errors until
        /// all sources have terminated.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="sources">The IEnumerable sequence if IPublisher sources.</param>
        /// <param name="delayError">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Concat<T>(IEnumerable<IPublisher<T>> sources, bool delayError = false)
        {
            return new PublisherConcatEnumerable<T>(sources, delayError);
        }

        /// <summary>
        /// Concatenates an parameter array of IPublisher sources.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="delayErrors">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <param name="sources">The IEnumerable sequence if IPublisher sources.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Concat<T>(bool delayErrors = false, params IPublisher<T>[] sources)
        {
            return new PublisherConcatArray<T>(sources, delayErrors);
        }

        /// <summary>
        /// Concatenates a dynamic sequence of IPublisher sources, optionally delaying errors from the outer IPublisher
        /// and the inner IPublishers until the current IPublisher terminates or all IPublishers terminated.
        /// </summary>
        /// <remarks>
        /// The operator prefetches 2 elements from the outer IPublisher, keeping them ready for subscription
        /// once the current inner IPublisher terminates.
        /// </remarks>
        /// <remarks>
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions.
        /// </remarks>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="sources">The dynamic sequence of IPublisher sources.</param>
        /// <param name="errorMode">Specifies the error handling behavior. See <see cref="ConcatErrorMode"/> constants.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Concat<T>(IPublisher<IPublisher<T>> sources, ConcatErrorMode errorMode = ConcatErrorMode.Immediate)
        {
            return Concat(sources, 2, errorMode);
        }

        /// <summary>
        /// Concatenates a dynamic sequence of IPublisher sources, optionally delaying errors from the outer IPublisher
        /// and the inner IPublishers until the current IPublisher terminates or all IPublishers terminated, plus it
        /// allows specifying how many elements to prefetch from the outer IPublisher.
        /// </summary>
        /// <remarks>
        /// The operator keeps a low-watermark of 25% of the specified prefetch amount.
        /// </remarks>
        /// <remarks>
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions.
        /// </remarks>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="sources">The dynamic sequence of IPublisher sources.</param>
        /// <param name="prefetch">The number of items to prefetch from the outer IPublisher. If negative, the outer IPublisher is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <param name="errorMode">Specifies the error handling behavior. See <see cref="ConcatErrorMode"/> constants.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Concat<T>(IPublisher<IPublisher<T>> sources, int prefetch, ConcatErrorMode errorMode = ConcatErrorMode.Immediate)
        {
            return new PublisherConcatMap<IPublisher<T>, T>(sources, v => v, prefetch, errorMode);
        }

        /// <summary>
        /// Creates an IFlux which when subscribed to, calls the specified Action with a IFluxEmitter instance that takes
        /// care of signalling events and handling backpressure for the downstream.
        /// </summary>
        /// <typeparam name="T">The value type signalled.</typeparam>
        /// <param name="emitter">The action called for each incoming subscriber with an IFluxEmitter instance.</param>
        /// <param name="backpressure">Specifies how to handle downstream backpressure. See <see cref="BackpressureHandling"/> for values.</param>
        /// <returns>The new IFlux isntance.</returns>
        public static IFlux<T> Create<T>(Action<IFluxEmitter<T>> emitter, BackpressureHandling backpressure = BackpressureHandling.Error)
        {
            return new PublisherCreate<T>(emitter, backpressure);
        }

        /// <summary>
        /// Supply a IPublisher everytime subscribe is called on the returned flux. The passed supplier function
        /// will be invoked and it's up to the developer to choose to return a new instance of a IPublisher or reuse
        /// one effecitvely behaving like from(IPublisher).
        /// </summary>
        /// <typeparam name="T">The type of values passing through the IFlux.</typeparam>
        /// <param name="supplier">The IPublisher supplier function to call on subscribe.</param>
        /// <returns>A deferred IFlux.</returns>
        public static IFlux<T> Defer<T>(Func<IPublisher<T>> supplier)
        {
            return new PublisherDefer<T>(supplier);
        }

        /// <summary>
        /// Creates an IFlux instance which signals the given exception
        /// immediately (or when requested).
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="ex">The exception to signal</param>
        /// <param name="whenRequested">Signal the exception when requested?</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Error<T>(Exception ex, bool whenRequested = false)
        {
            return new PublisherError<T>(ex, whenRequested);
        }

        /// <summary>
        /// Relays signals from that source IPublisher that signalled anything first (cancels or doesn't even
        /// subscribe to the rest).
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="sources">The parameter array of IPublisher sources.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> FirstEmitting<T>(params IPublisher<T>[] sources)
        {
            return new PublisherAmb<T>(sources, null);
        }

        /// <summary>
        /// Relays signals from that source IPublisher that signalled anything first (cancels or doesn't even
        /// subscribe to the rest).
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="sources">The IEnumerable sequence of IPublisher sources.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> FirstEmitting<T>(IEnumerable<IPublisher<T>> sources)
        {
            return new PublisherAmb<T>(null, sources);
        }

        /// <summary>
        /// Expose the specified IPublisher with the IFlux API.
        /// </summary>
        /// <typeparam name="T">the source sequence type</typeparam>
        /// <param name="source">the source to decorate</param>
        /// <returns>The source or an new IFlux wrapper of it.</returns>
        public static IFlux<T> From<T>(IPublisher<T> source)
        {
            if (source is IFlux<T>)
            {
                return (IFlux<T>)source;
            }
            return new PublisherWrap<T>(source);
        }

        /// <summary>
        /// Emits the elements of the given parameter array.
        /// </summary>
        /// <typeparam name="T">The element type of the array.</typeparam>
        /// <param name="values">The array of values to emit.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> From<T>(params T[] values)
        {
            int n = values.Length;
            ;
            if (n == 0)
            {
                return Empty<T>();
            }
            else
            if (n == 1)
            {
                return Just(values[0]);
            }
            return new PublisherArray<T>(values);
        }

        /// <summary>
        /// Emits the elements of the given IEnumerable sequence.
        /// </summary>
        /// <typeparam name="T">The element type of the IEnumerable.</typeparam>
        /// <param name="enumerable">The IEnumerable source of elements to signal.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> From<T>(IEnumerable<T> enumerable)
        {
            return new PublisherEnumerable<T>(enumerable);
        }

        /// <summary>
        /// Wraps the specified IObservable into an IFlux and applies the specified backpressure strategy
        /// (IObservables don't support backpressure on their own).
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IObservable instance.</param>
        /// <param name="backpressure">The backpressure strategy. See <see cref="BackpressureHandling"/> enum constants.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> From<T>(IObservable<T> source, BackpressureHandling backpressure = BackpressureHandling.Error)
        {
            return new PublisherFromObservable<T>(source, backpressure);
        }

        /// <summary>
        /// Creates a valueless IFlux instance from the task which
        /// signals when the task completes or fails.
        /// </summary>
        /// <param name="task">The tast to use as source.</param>
        /// <returns>The IFlux instance</returns>
        public static IFlux<Void> From(Task task)
        {
            return new PublisherFromTask(task);
        }

        /// <summary>
        /// Creates a IFlux instance from the task which
        /// signals a single value when the task completes or 
        /// signals an Exception if the task fails.
        /// </summary>
        /// <param name="task">The tast to use as source.</param>
        /// <returns>The IFlux instance</returns>
        public static IFlux<T> From<T>(Task<T> task)
        {
            return new PublisherFromTask<T>(task);
        }

        /// <summary>
        /// Executes the given action for each subscriber and completes
        /// or signals an Exception if the action threw.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="action">The action</param>
        /// <returns>The IMono instance</returns>
        public static IFlux<T> From<T>(Action action)
        {
            return new PublisherAction<T>(action);
        }

        /// <summary>
        /// Emits the value returned by the supplier function to each individual subscriber.
        /// </summary>
        /// <typeparam name="T">The emitted value type.</typeparam>
        /// <param name="supplier">The function that is called for each subscriber to return a value to be emitted.</param>
        /// <param name="nullMeansEmpty">If the supplier returns null, should that be considered as empty source?
        /// Note that value types don't have a notion of null and their default value is considered a normal value.</param>
        /// <returns></returns>
        public static IFlux<T> From<T>(Func<T> supplier, bool nullMeansEmpty = false)
        {
            return new PublisherFunc<T>(supplier, nullMeansEmpty);
        }

        /// <summary>
        /// Generates signals when the downstream requests values in a stateless manner.
        /// </summary>
        /// <remarks>
        /// The generator action is called as many times as the downstream amount.
        /// For example, a downstream request(2) will call the action twice.
        /// </remarks>
        /// <typeparam name="T">The generated value type.</typeparam>
        /// <param name="generator">The action called with an ISignalEmitter instance for each 
        /// subscriber and for each downstream request to generate the next value to emit or a 
        /// teriman signal.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Generate<T>(Action<ISignalEmitter<T>> generator)
        {
            return Generate<T, object>(() => default(object), (s, e) => { generator(e); return s; }, s => { });
        }

        /// <summary>
        /// Generates signals when the downstream requests values in a stateful manner.
        /// </summary>
        /// <remarks>
        /// The generator action is called as many times as the downstream amount.
        /// For example, a downstream request(2) will call the action twice.
        /// </remarks>
        /// <typeparam name="T">The generated value type.</typeparam>
        /// <typeparam name="S">The state type.</typeparam>
        /// <param name="stateSupplier">The function returning the initial state object or structure for each subscriber.</param>
        /// <param name="generator">The action called with the current state value and a ISignalEmitter instance for each 
        /// subscriber and for each downstream request to generate the next value to emit or a 
        /// teriman signal. The function's return value should be the new state (which is used the next time this function is called).</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Generate<T, S>(Func<S> stateSupplier, Func<S, ISignalEmitter<T>, S> generator)
        {
            return Generate(stateSupplier, generator, s => { });
        }

        /// <summary>
        /// Generates signals when the downstream requests values in a stateful manner.
        /// </summary>
        /// <remarks>
        /// The generator action is called as many times as the downstream amount.
        /// For example, a downstream request(2) will call the action twice.
        /// </remarks>
        /// <typeparam name="T">The generated value type.</typeparam>
        /// <typeparam name="S">The state type.</typeparam>
        /// <param name="stateSupplier">The function returning the initial state object or structure for each subscriber.</param>
        /// <param name="generator">The action called with the current state value and a ISignalEmitter instance for each 
        /// subscriber and for each downstream request to generate the next value to emit or a 
        /// teriman signal. The function's return value should be the new state (which is used the next time this function is called).</param>
        /// <param name="stateDisposer">The action to call to dispose the state generated/modified by the other functions. This function
        /// is called exactly once for each subscriber whenever the generator signals a terminal event or the sequence gets cancelled.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Generate<T, S>(Func<S> stateSupplier, Func<S, ISignalEmitter<T>, S> generator, Action<S> stateDisposer)
        {
            return new PublisherGenerate<T, S>(stateSupplier, generator, stateDisposer);
        }

        /// <summary>
        /// Generates a sequence of long numbers, starting from 0, with the given periodicity, running
        /// on the default timed scheduler.
        /// </summary>
        /// <param name="period">The period at which numbers are signalled.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<long> Interval(TimeSpan period)
        {
            return Interval(period, period, DefaultScheduler.Instance);
        }

        /// <summary>
        /// Generates a sequence of long numbers, starting from 0, with the given periodicity, running
        /// on the specified timed scheduler.
        /// </summary>
        /// <param name="period">The period at which numbers are signalled.</param>
        /// <param name="scheduler">The scheduler to use for emitting each number.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<long> Interval(TimeSpan period, TimedScheduler scheduler)
        {
            return Interval(period, period, scheduler);
        }

        /// <summary>
        /// Generates a sequence of long numbers, starting from 0, with the given periodicity and after the
        /// initial delay, running on the default timed scheduler.
        /// </summary>
        /// <param name="initialDelay">The initial delay before signalling 0.</param>
        /// <param name="period">The period at which subsequent numbers are signalled.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<long> Interval(TimeSpan initialDelay, TimeSpan period)
        {
            return Interval(initialDelay, period, DefaultScheduler.Instance);
        }

        /// <summary>
        /// Generates a sequence of long numbers, starting from 0, with the given periodicity and after the
        /// initial delay, running on the default timed scheduler.
        /// </summary>
        /// <param name="initialDelay">The initial delay before signalling 0.</param>
        /// <param name="period">The period at which numbers are signalled.</param>
        /// <param name="scheduler">The scheduler to use for emitting each number.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<long> Interval(TimeSpan initialDelay, TimeSpan period, TimedScheduler scheduler)
        {
            return new PublisherInterval(initialDelay, period, scheduler);
        }

        /// <summary>
        /// Merges the values from the specified parameter array of source IPublishers, optionally delaying
        /// any of their errors until all sources terminate.
        /// </summary>
        /// <remarks>
        /// The operator merges at most <see cref="BufferSize"/> number of sources at once and uses
        /// <see cref="BufferSize"/> prefetch for those sources.
        /// </remarks>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="delayErrors">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <param name="sources">The parameter array of IPublisher sources to merge.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Merge<T>(bool delayErrors = false, params IPublisher<T>[] sources)
        {
            return Merge(BufferSize, BufferSize, delayErrors, sources);
        }

        /// <summary>
        /// Merges the values from the specified parameter array of source IPublishers, at most
        /// <paramref name="maxConcurrency"/> sources at once, optionally delaying any of their errors until
        /// all sources terminate.
        /// </summary>
        /// <remarks>
        /// The operator uses <see cref="BufferSize"/> prefetch for those sources.
        /// </remarks>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="maxConcurrency">The maximum number of sources to merge at once.</param>
        /// <param name="delayErrors">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <param name="sources">The parameter array of IPublisher sources to merge.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Merge<T>(int maxConcurrency, bool delayErrors = false, params IPublisher<T>[] sources)
        {
            return Merge(BufferSize, maxConcurrency, delayErrors, sources);
        }

        /// <summary>
        /// Merges the values from the specified parameter array of source IPublishers, at most
        /// <paramref name="maxConcurrency"/> sources at once, using the specified prefetch for these sources,
        /// optionally delaying any of their errors until all sources terminate.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="maxConcurrency">The maximum number of sources to merge at once.</param>
        /// <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <param name="delayErrors">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <param name="sources">The parameter array of IPublisher sources to merge.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Merge<T>(int maxConcurrency, int prefetch, bool delayErrors = false, params IPublisher<T>[] sources)
        {
            // TODO implement Merge
            throw new NotImplementedException();
        }

        /// <summary>
        /// Merges the values from the specified IEnumerable sequence of source IPublishers, optionally delaying
        /// any of their errors until all sources terminate.
        /// </summary>
        /// <remarks>
        /// The operator merges at most <see cref="BufferSize"/> number of sources at once and uses
        /// <see cref="BufferSize"/> prefetch for those sources.
        /// </remarks>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="delayErrors">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <param name="sources">The IEnumerable sequence of IPublisher sources to merge.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Merge<T>(IEnumerable<IPublisher<T>> sources, bool delayErrors = false)
        {
            return Merge(sources, BufferSize, BufferSize, delayErrors);
        }

        /// <summary>
        /// Merges the values from the specified IEnumerable sequence of source IPublishers, at most
        /// <paramref name="maxConcurrency"/> sources at once, optionally delaying any of their errors until
        /// all sources terminate.
        /// </summary>
        /// <remarks>
        /// The operator uses <see cref="BufferSize"/> prefetch for those sources.
        /// </remarks>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="maxConcurrency">The maximum number of sources to merge at once.</param>
        /// <param name="delayErrors">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <param name="sources">The IEnumerable sequence of IPublisher sources to merge.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Merge<T>(IEnumerable<IPublisher<T>> sources, int maxConcurrency, bool delayErrors = false)
        {
            return Merge(sources, BufferSize, maxConcurrency, delayErrors);
        }

        /// <summary>
        /// Merges the values from the specified IEnumerable sequence of source IPublishers, at most
        /// <paramref name="maxConcurrency"/> sources at once, using the specified prefetch for these sources,
        /// optionally delaying any of their errors until all sources terminate.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="maxConcurrency">The maximum number of sources to merge at once.</param>
        /// <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <param name="delayErrors">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <param name="sources">The IEnumerable sequence of IPublisher sources to merge.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Merge<T>(IEnumerable<IPublisher<T>> sources, int maxConcurrency, int prefetch, bool delayErrors = false)
        {
            return From(sources).FlatMap(v => v, maxConcurrency, prefetch, delayErrors);
        }

        /// <summary>
        /// Merges the values from the specified dynamic outer IPublisher sequence of inner source IPublishers, optionally delaying
        /// any of their errors until all sources terminate.
        /// </summary>
        /// <remarks>
        /// The operator merges at most <see cref="BufferSize"/> number of sources at once and uses
        /// <see cref="BufferSize"/> prefetch for those sources.
        /// </remarks>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="delayErrors">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <param name="sources">The dynamic outer IPublisher of inner IPublisher sources to merge.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Merge<T>(this IPublisher<IPublisher<T>> sources, bool delayErrors = false)
        {
            return Merge(sources, BufferSize, BufferSize, delayErrors);
        }

        /// <summary>
        /// Merges the values from the specified dynamic outer IPublisher sequence of inner source IPublishers, at most
        /// <paramref name="maxConcurrency"/> sources at once, optionally delaying any of their errors until
        /// all sources terminate.
        /// </summary>
        /// <remarks>
        /// The operator uses <see cref="BufferSize"/> prefetch for those sources.
        /// </remarks>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="maxConcurrency">The maximum number of inner sources to merge at once.</param>
        /// <param name="delayErrors">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <param name="sources">The dynamic outer IPublisher of inner IPublisher sources to merge.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Merge<T>(this IPublisher<IPublisher<T>> sources, int maxConcurrency = int.MaxValue, bool delayErrors = false)
        {
            return Merge(sources, BufferSize, maxConcurrency, delayErrors);
        }

        /// <summary>
        /// Merges the values from the specified dynamic outer IPublisher sequence of inner IPublishers, at most
        /// <paramref name="maxConcurrency"/> sources at once, using the specified prefetch for these sources,
        /// optionally delaying any of their errors until all sources terminate.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="maxConcurrency">The maximum number of inner sources to merge at once.</param>
        /// <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <param name="delayErrors">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <param name="sources">The dynamic outer IPublisher of inner IPublisher sources to merge.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Merge<T>(this IPublisher<IPublisher<T>> sources, int prefetch, int maxConcurrency = int.MaxValue, bool delayErrors = false)
        {
            return new PublisherFlatMap<IPublisher<T>, T>(sources, v => v, delayErrors, maxConcurrency, prefetch);
        }

        /// <summary>
        /// Signals a range of values from start to start + count (exclusive).
        /// </summary>
        /// <param name="start">The start value</param>
        /// <param name="count">The number of items, non-negative</param>
        /// <returns></returns>
        public static IFlux<int> Range(int start, int count)
        {
            if (count == 0)
            {
                return Empty<int>();
            }
            else
            if (count == 1)
            {
                return Just(start);
            }
            return new PublisherRange(start, count);
        }

        /// <summary>
        /// Creates an IFluxProcessor that accepts IPublisher instances, subscribes to them and
        /// relays signals from them until the next IPublisher is signalled to the IFluxProcessor.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <returns>The new IFluxProcessor instance.</returns>
        public static IFluxProcessor<IPublisher<T>, T> SwitchOnNext<T>()
        {
            return SwitchOnNext<T>(BufferSize);
        }

        /// <summary>
        /// Creates an IFluxProcessor that accepts IPublisher instances, subscribes to them and
        /// relays signals from them until the next IPublisher is signalled to the IFluxProcessor.
        /// Each IPublisher instance is prefetched with the specified amount and using a low-watermark
        /// of 25%.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <returns>The new IFluxProcessor instance.</returns>
        public static IFluxProcessor<IPublisher<T>, T> SwitchOnNext<T>(int prefetch)
        {
            // TODO implement SwitchOnNext
            throw new NotImplementedException();
        }

        /// <summary>
        /// Relays signals of the inner IPublisher sources until the outer IPublisher produces another inner source.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="sources">The dynamic IPublisher sequence of inner IPublisher sources.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> SwitchOnNext<T>(this IPublisher<IPublisher<T>> sources)
        {
            return SwitchOnNext<T>(sources, BufferSize);
        }

        /// <summary>
        /// Relays signals of the inner IPublisher sources until the outer IPublisher produces another inner source.
        /// It uses the given prefetch amount on the inner IPublisher sources.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="sources">The dynamic IPublisher sequence of inner IPublisher sources.</param>
        /// <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <returns></returns>
        public static IFlux<T> SwitchOnNext<T>(this IPublisher<IPublisher<T>> sources, int prefetch)
        {
            return new PublisherSwitchMap<IPublisher<T>, T>(sources, v => v, prefetch);
        }

        /// <summary>
        /// Signals a single long 0 after the specified delay on the default timed scheduler.
        /// </summary>
        /// <param name="delay">The delay amount.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<long> Timer(TimeSpan delay)
        {
            return Timer(delay, DefaultScheduler.Instance);
        }

        /// <summary>
        /// Signals a single long 0 after the specified delay on the specified timed scheduler.
        /// </summary>
        /// <param name="delay">The delay amount.</param>
        /// <param name="scheduler">The target timed scheduler.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<long> Timer(TimeSpan delay, TimedScheduler scheduler)
        {
            return new PublisherTimer(delay, scheduler);
        }

        /// <summary>
        /// Uses a generated resource, derives an IPublisher from it whose signals are relayed and
        /// disposes the generated resource once the IPublisher terminates or gets cancelled.
        /// </summary>
        /// <typeparam name="T">The value type signalled.</typeparam>
        /// <typeparam name="S">The resource type.</typeparam>
        /// <param name="resourceSupplier">Function that returns a resource for each subscriber</param>
        /// <param name="publisherFactory">Function that receives the generated resource and returns an IPublisher to be relayed for each subscriber.</param>
        /// <param name="resourceDisposer">The action called to dispose the generated resource.</param>
        /// <param name="eager">If true, the resourceDisposer is called before signalling the terminal event; after otherwise.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Using<T, S>(Func<S> resourceSupplier, Func<S, IPublisher<T>> publisherFactory, Action<S> resourceDisposer, bool eager = true)
        {
            return new PublisherUsing<T, S>(resourceSupplier, publisherFactory, resourceDisposer, eager);
        }

        /// <summary>
        /// Combines a row of values, the next from each IPublisher source, through a function and emits the resulting value.
        /// </summary>
        /// <typeparam name="T">The input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="zipper">The function that receives an array of values, as many as there are sources and returns
        /// a value to be emitted.</param>
        /// <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
        /// signalling an AggregateException if there were more than one Exception.</param>
        /// <param name="sources">The parameter array of IPublisher sources to combine.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> Zip<T, R>(Func<T[], R> zipper, bool delayErrors = false, params IPublisher<T>[] sources)
        {
            return Zip(zipper, BufferSize, delayErrors, sources);
        }

        /// <summary>
        /// Combines a row of values, the next from each IPublisher source, through a function and emits the resulting value
        /// while prefetching the given amount from each of these IPublisher sources.
        /// </summary>
        /// <typeparam name="T">The input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="zipper">The function that receives an array of values, as many as there are sources and returns
        /// a value to be emitted.</param>
        /// <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
        /// signalling an AggregateException if there were more than one Exception.</param>
        /// <param name="sources">The parameter array of IPublisher sources to combine.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> Zip<T, R>(Func<T[], R> zipper, int prefetch, bool delayErrors = false, params IPublisher<T>[] sources)
        {
            // TODO implement Using
            throw new NotImplementedException();
        }

        /// <summary>
        /// Combines a row of values, the next from each IPublisher source from the IEnumerable sequence,
        /// through a function and emits the resulting value.
        /// </summary>
        /// <typeparam name="T">The input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="zipper">The function that receives an array of values, as many as there are sources and returns
        /// a value to be emitted.</param>
        /// <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
        /// signalling an AggregateException if there were more than one Exception.</param>
        /// <param name="sources">The IEnumerable sequence of IPublisher sources to combine.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> Zip<T, R>(IEnumerable<IPublisher<T>> sources, Func<T[], R> zipper, bool delayErrors = false)
        {
            return Zip(sources, zipper, BufferSize);
        }

        /// <summary>
        /// Combines a row of values, the next from each IPublisher source from the IEnumerable sequence,
        /// through a function and emits the resulting value
        /// while prefetching the given amount from each of these IPublisher sources.
        /// </summary>
        /// <typeparam name="T">The input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="zipper">The function that receives an array of values, as many as there are sources and returns
        /// a value to be emitted.</param>
        /// <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
        /// signalling an AggregateException if there were more than one Exception.</param>
        /// <param name="sources">The IEnumerable sequence of IPublisher sources to combine.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> Zip<T, R>(IEnumerable<IPublisher<T>> sources, Func<T[], R> zipper, int prefetch, bool delayErrors = false)
        {
            // TODO implement Zip
            throw new NotImplementedException();
        }

        /// <summary>
        /// Combines a row of values, the next from each IPublisher source,
        /// through a function and emits the resulting value.
        /// </summary>
        /// <typeparam name="T1">The first input value type.</typeparam>
        /// <typeparam name="T2">The second input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="p1">The first source IPublisher.</param>
        /// <param name="p2">The second source IPublisher.</param>
        /// <param name="zipper">The function that receives an array of values, as many as there are sources and returns
        /// a value to be emitted.</param>
        /// <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
        /// signalling an AggregateException if there were more than one Exception.</param>
        public static IFlux<R> Zip<T1, T2, R>(IPublisher<T1> p1, IPublisher<T2> p2, Func<T1, T2, R> zipper, bool delayErrors = false)
        {
            return Zip(p1, p2, zipper, BufferSize, delayErrors);
        }

        /// <summary>
        /// Combines a row of values, the next from each IPublisher source,
        /// through a function and emits the resulting value.
        /// </summary>
        /// <typeparam name="T1">The first input value type.</typeparam>
        /// <typeparam name="T2">The second input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="p1">The first source IPublisher.</param>
        /// <param name="p2">The second source IPublisher.</param>
        /// <param name="zipper">The function that receives an array of values, as many as there are sources and returns
        /// a value to be emitted.</param>
        /// <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
        /// signalling an AggregateException if there were more than one Exception.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> Zip<T1, T2, R>(IPublisher<T1> p1, IPublisher<T2> p2, Func<T1, T2, R> zipper, int prefetch, bool delayErrors = false)
        {
            return Zip<object, R>(a =>
            {
                return zipper((T1)a[0], (T2)a[1]);
            },
                BufferSize, delayErrors,
                Box(p1), Box(p2)
            );
        }

        /// <summary>
        /// Combines a row of values, the next from each IPublisher source,
        /// through a function and emits the resulting value.
        /// </summary>
        /// <typeparam name="T1">The first input value type.</typeparam>
        /// <typeparam name="T2">The second input value type.</typeparam>
        /// <typeparam name="T3">The third input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="p1">The first source IPublisher.</param>
        /// <param name="p2">The second source IPublisher.</param>
        /// <param name="p3">The third source IPublisher.</param>
        /// <param name="zipper">The function that receives an array of values, as many as there are sources and returns
        /// a value to be emitted.</param>
        /// <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
        /// signalling an AggregateException if there were more than one Exception.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> Zip<T1, T2, T3, R>(
            IPublisher<T1> p1, IPublisher<T2> p2,
            IPublisher<T2> p3,
            Func<T1, T2, T3, R> zipper, bool delayErrors = false)
        {
            return Zip(p1, p2, p3, zipper, BufferSize, delayErrors);
        }

        /// <summary>
        /// Combines a row of values, the next from each IPublisher source,
        /// through a function and emits the resulting value.
        /// </summary>
        /// <typeparam name="T1">The first input value type.</typeparam>
        /// <typeparam name="T2">The second input value type.</typeparam>
        /// <typeparam name="T3">The third input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="p1">The first source IPublisher.</param>
        /// <param name="p2">The second source IPublisher.</param>
        /// <param name="p3">The third source IPublisher.</param>
        /// <param name="zipper">The function that receives an array of values, as many as there are sources and returns
        /// a value to be emitted.</param>
        /// <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
        /// signalling an AggregateException if there were more than one Exception.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> Zip<T1, T2, T3, R>(
            IPublisher<T1> p1, IPublisher<T2> p2,
            IPublisher<T2> p3,
            Func<T1, T2, T3, R> zipper,
            int prefetch, bool delayErrors = false)
        {
            return Zip<object, R>(a =>
            {
                return zipper((T1)a[0], (T2)a[1], (T3)a[2]);
            },
                BufferSize, delayErrors,
                Box(p1), Box(p2), Box(p3)
            );
        }

        /// <summary>
        /// Combines a row of values, the next from each IPublisher source,
        /// through a function and emits the resulting value.
        /// </summary>
        /// <typeparam name="T1">The first input value type.</typeparam>
        /// <typeparam name="T2">The second input value type.</typeparam>
        /// <typeparam name="T3">The third input value type.</typeparam>
        /// <typeparam name="T4">The fourth input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="p1">The first source IPublisher.</param>
        /// <param name="p2">The second source IPublisher.</param>
        /// <param name="p3">The third source IPublisher.</param>
        /// <param name="p4">The fourth source IPublisher.</param>
        /// <param name="zipper">The function that receives an array of values, as many as there are sources and returns
        /// a value to be emitted.</param>
        /// <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
        /// signalling an AggregateException if there were more than one Exception.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> Zip<T1, T2, T3, T4, R>(
            IPublisher<T1> p1, IPublisher<T2> p2,
            IPublisher<T2> p3, IPublisher<T4> p4,
            Func<T1, T2, T3, T4, R> zipper, bool delayErrors = false)
        {
            return Zip(p1, p2, p3, p4, zipper, BufferSize, delayErrors);
        }

        /// <summary>
        /// Combines a row of values, the next from each IPublisher source,
        /// through a function and emits the resulting value.
        /// </summary>
        /// <typeparam name="T1">The first input value type.</typeparam>
        /// <typeparam name="T2">The second input value type.</typeparam>
        /// <typeparam name="T3">The third input value type.</typeparam>
        /// <typeparam name="T4">The fourth input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="p1">The first source IPublisher.</param>
        /// <param name="p2">The second source IPublisher.</param>
        /// <param name="p3">The third source IPublisher.</param>
        /// <param name="p4">The fourth source IPublisher.</param>
        /// <param name="zipper">The function that receives an array of values, as many as there are sources and returns
        /// a value to be emitted.</param>
        /// <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
        /// signalling an AggregateException if there were more than one Exception.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> Zip<T1, T2, T3, T4, R>(
            IPublisher<T1> p1, IPublisher<T2> p2,
            IPublisher<T2> p3, IPublisher<T4> p4,
            Func<T1, T2, T3, T4, R> zipper,
            int prefetch, bool delayErrors = false)
        {
            return Zip<object, R>(a =>
            {
                return zipper((T1)a[0], (T2)a[1], (T3)a[2], (T4)a[3]);
            },
                BufferSize, delayErrors,
                Box(p1), Box(p2), Box(p3), Box(p4)
            );
        }

        /// <summary>
        /// Combines a row of values, the next from each IPublisher source,
        /// through a function and emits the resulting value.
        /// </summary>
        /// <typeparam name="T1">The first input value type.</typeparam>
        /// <typeparam name="T2">The second input value type.</typeparam>
        /// <typeparam name="T3">The third input value type.</typeparam>
        /// <typeparam name="T4">The fourth input value type.</typeparam>
        /// <typeparam name="T5">The fifth input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="p1">The first source IPublisher.</param>
        /// <param name="p2">The second source IPublisher.</param>
        /// <param name="p3">The third source IPublisher.</param>
        /// <param name="p4">The fourth source IPublisher.</param>
        /// <param name="p5">The fifth source IPublisher.</param>
        /// <param name="zipper">The function that receives an array of values, as many as there are sources and returns
        /// a value to be emitted.</param>
        /// <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
        /// signalling an AggregateException if there were more than one Exception.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> Zip<T1, T2, T3, T4, T5, R>(
            IPublisher<T1> p1, IPublisher<T2> p2,
            IPublisher<T2> p3, IPublisher<T4> p4,
            IPublisher<T5> p5,
            Func<T1, T2, T3, T4, T5, R> zipper, bool delayErrors = false)
        {
            return Zip(p1, p2, p3, p4, p5, zipper, BufferSize, delayErrors);
        }

        /// <summary>
        /// Combines a row of values, the next from each IPublisher source,
        /// through a function and emits the resulting value.
        /// </summary>
        /// <typeparam name="T1">The first input value type.</typeparam>
        /// <typeparam name="T2">The second input value type.</typeparam>
        /// <typeparam name="T3">The third input value type.</typeparam>
        /// <typeparam name="T4">The fourth input value type.</typeparam>
        /// <typeparam name="T5">The fifth input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="p1">The first source IPublisher.</param>
        /// <param name="p2">The second source IPublisher.</param>
        /// <param name="p3">The third source IPublisher.</param>
        /// <param name="p4">The fourth source IPublisher.</param>
        /// <param name="p5">The fifth source IPublisher.</param>
        /// <param name="zipper">The function that receives an array of values, as many as there are sources and returns
        /// a value to be emitted.</param>
        /// <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
        /// signalling an AggregateException if there were more than one Exception.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> Zip<T1, T2, T3, T4, T5, R>(
            IPublisher<T1> p1, IPublisher<T2> p2,
            IPublisher<T2> p3, IPublisher<T4> p4,
            IPublisher<T5> p5,
            Func<T1, T2, T3, T4, T5, R> zipper,
            int prefetch, bool delayErrors = false)
        {
            return Zip<object, R>(a =>
            {
                return zipper((T1)a[0], (T2)a[1], (T3)a[2], (T4)a[3], (T5)a[4]);
            },
                BufferSize, delayErrors,
                Box(p1), Box(p2), Box(p3), Box(p4), Box(p5)
            );
        }

        /// <summary>
        /// Combines a row of values, the next from each IPublisher source,
        /// through a function and emits the resulting value.
        /// </summary>
        /// <typeparam name="T1">The first input value type.</typeparam>
        /// <typeparam name="T2">The second input value type.</typeparam>
        /// <typeparam name="T3">The third input value type.</typeparam>
        /// <typeparam name="T4">The fourth input value type.</typeparam>
        /// <typeparam name="T5">The fifth input value type.</typeparam>
        /// <typeparam name="T6">The sixth input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="p1">The first source IPublisher.</param>
        /// <param name="p2">The second source IPublisher.</param>
        /// <param name="p3">The third source IPublisher.</param>
        /// <param name="p4">The fourth source IPublisher.</param>
        /// <param name="p5">The fifth source IPublisher.</param>
        /// <param name="p6">The sixth source IPublisher.</param>
        /// <param name="zipper">The function that receives an array of values, as many as there are sources and returns
        /// a value to be emitted.</param>
        /// <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
        /// signalling an AggregateException if there were more than one Exception.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> Zip<T1, T2, T3, T4, T5, T6, R>(
            IPublisher<T1> p1, IPublisher<T2> p2,
            IPublisher<T2> p3, IPublisher<T4> p4,
            IPublisher<T5> p5, IPublisher<T6> p6,
            Func<T1, T2, T3, T4, T5, T6, R> zipper, bool delayErrors = false)
        {
            return Zip(p1, p2, p3, p4, p5, p6, zipper, BufferSize, delayErrors);
        }

        /// <summary>
        /// Combines a row of values, the next from each IPublisher source,
        /// through a function and emits the resulting value.
        /// </summary>
        /// <typeparam name="T1">The first input value type.</typeparam>
        /// <typeparam name="T2">The second input value type.</typeparam>
        /// <typeparam name="T3">The third input value type.</typeparam>
        /// <typeparam name="T4">The fourth input value type.</typeparam>
        /// <typeparam name="T5">The fifth input value type.</typeparam>
        /// <typeparam name="T6">The sixth input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="p1">The first source IPublisher.</param>
        /// <param name="p2">The second source IPublisher.</param>
        /// <param name="p3">The third source IPublisher.</param>
        /// <param name="p4">The fourth source IPublisher.</param>
        /// <param name="p5">The fifth source IPublisher.</param>
        /// <param name="p6">The sixth source IPublisher.</param>
        /// <param name="zipper">The function that receives an array of values, as many as there are sources and returns
        /// a value to be emitted.</param>
        /// <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
        /// signalling an AggregateException if there were more than one Exception.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> Zip<T1, T2, T3, T4, T5, T6, R>(
            IPublisher<T1> p1, IPublisher<T2> p2,
            IPublisher<T2> p3, IPublisher<T4> p4,
            IPublisher<T5> p5, IPublisher<T6> p6,
            Func<T1, T2, T3, T4, T5, T6, R> zipper,
            int prefetch, bool delayErrors = false)
        {
            return Zip<object, R>(a =>
            {
                return zipper((T1)a[0], (T2)a[1], (T3)a[2], (T4)a[3], (T5)a[4], (T6)a[5]);
            },
                BufferSize, delayErrors,
                Box(p1), Box(p2), Box(p3), Box(p4), Box(p5), Box(p6)
            );
        }

        // ---------------------------------------------------------------------------------------------------------
        // Transform the reactive world
        // ---------------------------------------------------------------------------------------------------------

        /// <summary>
        /// Transform the items emitted by this IFlux by applying a function to each item.
        /// </summary>
        /// <typeparam name="T">The input value type</typeparam>
        /// <typeparam name="R">The output value type</typeparam>
        /// <param name="source">The source IFlux</param>
        /// <param name="mapper">The mapper from Ts to Rs</param>
        /// <returns>The new IFlux instance</returns>
        public static IFlux<R> Map<T, R>(this IFlux<T> source, Func<T, R> mapper)
        {
            return new PublisherMap<T, R>(source, mapper);
        }

        /// <summary>
        /// Apply the transformer function on the source IFlux; this allows fluent conversion
        /// to any other type.
        /// </summary>
        /// <typeparam name="T">The input IFlux value type.</typeparam>
        /// <typeparam name="R">The output type.</typeparam>
        /// <param name="source">The source IFlux to transform.</param>
        /// <param name="transformer">The transformer, receiving the IFlux source and returns a value.</param>
        /// <returns>The value returned by the transformer function.</returns>
        public static R As<T, R>(this IFlux<T> source, Func<IFlux<T>, R> transformer)
        {
            return transformer(source);
        }

        /// <summary>
        /// Returns an IMono containing true if the source contains any item the predicate
        /// matches.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="predicate">The predicate to apply to each item in the sequence.</param>
        /// <returns>The new IMono containing either true or false.</returns>
        public static IMono<bool> Any<T>(this IFlux<T> source, Func<T, bool> predicate)
        {
            // TODO implement Any
            throw new NotImplementedException();
        }

        /// <summary>
        /// Returns an IMono containing true if all items from the source match the predicate.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="predicate">The predicate to be mached by all source elements.</param>
        /// <returns>The new IMono instance.</returns>
        public static IMono<bool> All<T>(this IFlux<T> source, Func<T, bool> predicate)
        {
            // TODO implement All
            throw new NotImplementedException();
        }

        /// <summary>
        /// Buffers all elements from the source sequence into an IList.
        /// This operator requires a finite source.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <returns>The new IMono instance holding the IList of all source values.</returns>
        public static IMono<IList<T>> Buffer<T>(this IFlux<T> source)
        {
            // TODO implement Buffer
            throw new NotImplementedException();
        }

        /// <summary>
        /// Buffers elements into non-overlapping sub-buffers with the specified number of elements in
        /// each.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="size">The size of each IList buffer (except the last once which could be smaller).</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<IList<T>> Buffer<T>(this IFlux<T> source, int size)
        {
            return Buffer(source, size, size);
        }

        /// <summary>
        /// Buffers elements into potentially overlapping sub-buffers with the specified number of elements in
        /// each and sub-buffers started after the skip amount.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="size">The number of elements to store in each sub-buffer.</param>
        /// <param name="skip">The number of elements to let pass to start the next buffer.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<IList<T>> Buffer<T>(this IFlux<T> source, int size, int skip)
        {
            // TODO implement Buffer
            throw new NotImplementedException();
        }

        /// <summary>
        /// Buffers elements into non-overlapping sub-buffers whose boundary is established by
        /// an OnNext signal from the boundary IPublisher.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="U">The boundary value type.</typeparam>
        /// <param name="source">The source IFlux of values to buffer.</param>
        /// <param name="boundary">The boundary IPublisher signalling the end and start of each sub-buffer.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<IList<T>> Buffer<T, U>(this IFlux<T> source, IPublisher<U> boundary)
        {
            // TODO implement Buffer
            throw new NotImplementedException();
        }

        /// <summary>
        /// Buffers elements into potentially overlapping sub-buffers which are opened by an IPublisher
        /// and closed by another, derived IPublisher signalling.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="U">The buffer-opening sequence type.</typeparam>
        /// <typeparam name="V">The buffer-closing sequence type.</typeparam>
        /// <param name="source">The source IFlux</param>
        /// <param name="open">The IPublisher opening buffers</param>
        /// <param name="close">The function generating an IPublisher to close a buffer opened 
        /// by the value from <paramref name="open"/> sequence.</param>
        /// <returns>The nex IFlux instance.</returns>
        public static IFlux<IList<T>> Buffer<T, U, V>(this IFlux<T> source, IPublisher<U> open, Func<U, IPublisher<V>> close)
        {
            // TODO implement Buffer
            throw new NotImplementedException();
        }

        /// <summary>
        /// Buffers elements into non-overlapping sub-buffers for the specified timespan duration each.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="timespan">The time duration for each sub-buffer.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<IList<T>> Buffer<T>(this IFlux<T> source, TimeSpan timespan)
        {
            return Buffer(source, timespan, timespan, DefaultScheduler.Instance);
        }

        /// <summary>
        /// Buffers elements into non-overlapping sub-buffers for the specified timespan duration each,
        /// determined by the given timed scheduler.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="timespan">The time duration for each sub-buffer.</param>
        /// <param name="scheduler">The timed scheduler to give the notion of time for the sub-buffer duration</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<IList<T>> Buffer<T>(this IFlux<T> source, TimeSpan timespan, TimedScheduler scheduler)
        {
            return Buffer(source, timespan, timespan, scheduler);
        }

        /// <summary>
        /// Buffers elements into potentially overlapping sub-buffers, buffering for the specified timespan each
        /// and starting new buffers after the specified timeskip time.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="timespan">The duration for each sub-buffer.</param>
        /// <param name="timeskip">The time to skip before starting a new sub-buffer.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<IList<T>> Buffer<T>(this IFlux<T> source, TimeSpan timespan, TimeSpan timeskip)
        {
            return Buffer(source, timespan, timeskip, DefaultScheduler.Instance);
        }

        /// <summary>
        /// Buffers elements into potentially overlapping sub-buffers, buffering for the specified timespan each
        /// and starting new buffers after the specified timeskip time, as determined by the given timed scheduler.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="timespan">The duration for each sub-buffer.</param>
        /// <param name="timeskip">The time to skip before starting a new sub-buffer.</param>
        /// <param name="scheduler">The timed scheduler to provide the timing of sub-buffer boundaries.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<IList<T>> Buffer<T>(this IFlux<T> source, TimeSpan timespan, TimeSpan timeskip, TimedScheduler scheduler)
        {
            // TODO implement Buffer
            throw new NotImplementedException();
        }

        /// <summary>
        /// Buffer elements into non-overlapping sub-buffers limited by a maximum size or buffering duration.
        /// If the maximum size is reached, the time duration is restarted from that point.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="maxSize">The maximum number of elements in each sub-buffer.</param>
        /// <param name="timespan">The duration of buffering into each sub-buffer.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<IList<T>> Buffer<T>(this IFlux<T> source, int maxSize, TimeSpan timespan)
        {
            return Buffer(source, maxSize, timespan, DefaultScheduler.Instance);
        }

        /// <summary>
        /// Buffer elements into non-overlapping sub-buffers limited by a maximum size or buffering duration.
        /// If the maximum size is reached, the time duration is restarted from that point,
        /// where timing is determined by the given timed scheduler.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="maxSize">The maximum number of elements in each sub-buffer.</param>
        /// <param name="timespan">The duration of buffering into each sub-buffer.</param>
        /// <param name="scheduler">The timed scheduler to provide the timing of sub-buffer boundaries.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<IList<T>> Buffer<T>(this IFlux<T> source, int maxSize, TimeSpan timespan, TimedScheduler scheduler)
        {
            // TODO implement Buffer
            throw new NotImplementedException();
        }

        /// <summary>
        /// Caches all (or the last <paramref name="history"/>) elements from the source IFlux and
        /// replays them to every subscriber. The caching starts when the first subscriber subscribes.
        /// </summary>
        /// <remarks>
        /// The cache can't be cleared or restarted. See <see cref="Replay{T}(IFlux{T})"/> to.
        /// </remarks>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source sequence.</param>
        /// <param name="history">The number of elements to retain.</param>
        /// <returns>The IFlux instance.</returns>
        public static IFlux<T> Cache<T>(this IFlux<T> source, int history = int.MaxValue)
        {
            // TODO implement Cache
            throw new NotImplementedException();
        }

        /// <summary>
        /// Casts elements of the source sequence into the given type or
        /// signals InvalidCastException if any of the source elements can't
        /// be cast to that target type.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="R">The target value type.</typeparam>
        /// <param name="source">The source sequence.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> Cast<T, R>(this IFlux<T> source) where T: class where R: class
        {
            return Map(source, v =>
            {
                R r = v as R;
                if (v != null && r == null)
                {
                    throw new InvalidCastException();
                }
                return r;
            });
        }

        /// <summary>
        /// Collects values into a custom collection, provided by a factory for each subscriber,
        /// via a collector action and emits this collection at the end.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="C">The collection type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="collectionSupplier">The supplier of the collection.</param>
        /// <param name="collector">The action called with the collection and the current source value.</param>
        /// <returns>The new IMono instance with the collection.</returns>
        public static IMono<C> Collect<T, C>(this IFlux<T> source, Func<C> collectionSupplier, Action<C, T> collector)
        {
            return new PublisherCollect<T, C>(source, collectionSupplier, collector);
        }

        /// <summary>
        /// Collects all source values into an IList and returns it as an IMono.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="capacityHint">The expected number of elements. (Reduce number of times the list has to be resized).</param>
        /// <returns>The new IMono instance.</returns>
        public static IMono<IList<T>> CollectList<T>(this IFlux<T> source, int capacityHint = 16)
        {
            return Collect<T, IList<T>>(source, () => new List<T>(capacityHint), (c, t) => c.Add(t));
        }

        /// <summary>
        /// Collects all source values into an sorted IList and returns it as an IMono.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="comparer">The comparer function to compare elements.</param>
        /// <param name="capacityHint">The expected number of elements. (Reduce number of times the list has to be resized).</param>
        /// <returns>The new IMono instance.</returns>
        public static IMono<IList<T>> CollectSortedList<T>(this IFlux<T> source, IComparer<T> comparer, int capacityHint = 16)
        {
            return CollectList(source, capacityHint).Map(c => c.OrderBy(v => v, comparer).ToList());
        }

        /// <summary>
        /// Collects all values into a Dictionary where the keys are derived via function.
        /// </summary>
        /// <remarks>
        /// Source values mapping to the same key are overwritten.
        /// </remarks>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="K">The key type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="keySelector">The function that extracts the key from the source values.</param>
        /// <returns>The new IMono instance.</returns>
        public static IMono<IDictionary<K, T>> CollectDictionary<T, K>(this IFlux<T> source, Func<T, K> keySelector)
        {
            return CollectDictionary(source, keySelector, v => v);
        }

        /// <summary>
        /// Collects all values into a Dictionary where the keys and values are derived via functions.
        /// </summary>
        /// <remarks>
        /// Source values mapping to the same key are overwritten.
        /// </remarks>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="K">The key type.</typeparam>
        /// <typeparam name="V">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="keySelector">The function that extracts the key from the source element.</param>
        /// <param name="valueSelector">The function that extracts the value from the source element</param>
        /// <returns>The new IMono instance.</returns>
        public static IMono<IDictionary<K, V>> CollectDictionary<T, K, V>(this IFlux<T> source, Func<T, K> keySelector, Func<T, V> valueSelector)
        {
            return Collect<T, IDictionary<K, V>>(source, () => new Dictionary<K, V>(), (d, t) =>
            {
                var k = keySelector(t);
                if (d.ContainsKey(k))
                {
                    d[k] = valueSelector(t);
                }
                else
                {
                    d.Add(k, valueSelector(t));
                }
            });
        }

        /// <summary>
        /// Collects elements mapping to the same key through a function into a list in a dictionary.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="K">The key type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="keySelector">The function that extracts the key from the source element.</param>
        /// <returns>The new IMono instance.</returns>
        public static IMono<IDictionary<K, IList<T>>> CollectMultiDictionary<T, K>(this IFlux<T> source, Func<T, K> keySelector)
        {
            return CollectMultiDictionary(source, keySelector, v => v);
        }

        /// <summary>
        /// Collects elements, transformed by a function, mapping to the same key through a function into a list in a dictionary.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="K">The key type.</typeparam>
        /// <typeparam name="V">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="keySelector">The function that extracts the key from the source element.</param>
        /// <param name="valueSelector">The function that extracts the value from each source element.</param>
        /// <returns>The new IMono instance.</returns>
        public static IMono<IDictionary<K, IList<V>>> CollectMultiDictionary<T, K, V>(this IFlux<T> source, Func<T, K> keySelector, Func<T, V> valueSelector)
        {
            return Collect<T, IDictionary<K, IList<V>>>(source, () => new Dictionary<K, IList<V>>(), (d, t) =>
            {
                var k = keySelector(t);
                if (d.ContainsKey(k))
                {
                    var list = d[k];
                    list.Add(valueSelector(t));
                }
                else
                {
                    var list = new List<V>();
                    list.Add(valueSelector(t));
                    d.Add(k, list);
                }
            });
        }

        /// <summary>
        /// Transforms the source IFlux into an IPublisher at subscription time (for each subscriber), allowing
        /// custom behavior to be injected into a flow.
        /// </summary>
        /// <remarks>
        /// Because the function is called at subscription time, the composition can have sequence-local
        /// state associated. 
        /// <p/>
        /// To do an assembly time composition, use the <see cref="As{T, R}(IFlux{T}, Func{IFlux{T}, R})"/>
        /// operator with a IPublisher-returning function.
        /// </remarks>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="R">The output value type</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="composer">The function called for each subscriber, receiving the source and returning
        /// an IPublisher that will be subscribed to.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> Compose<T, R>(this IFlux<T> source, Func<IFlux<T>, IPublisher<R>> composer)
        {
            return Defer(() => composer(source));
        }

        /// <summary>
        /// Concatenates IPublishers generated by a mapper function from the values of the source IPublisher.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="R">The result value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="mapper">The function that maps each source value into an IPublisher.</param>
        /// <param name="errorMode">Specifies the error handling behavior. See <see cref="ConcatErrorMode"/> constants.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> ConcatMap<T, R>(this IFlux<T> source, Func<T, IPublisher<R>> mapper, ConcatErrorMode errorMode = ConcatErrorMode.Immediate)
        {
            return ConcatMap(source, mapper, BufferSize, errorMode);
        }

        /// <summary>
        /// Concatenates IPublishers generated by a mapper function from the values of the source IPublisher.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="R">The result value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="mapper">The function that maps each source value into an IPublisher.</param>
        /// <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <param name="errorMode">Specifies the error handling behavior. See <see cref="ConcatErrorMode"/> constants.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> ConcatMap<T, R>(this IFlux<T> source, Func<T, IPublisher<R>> mapper, int prefetch, ConcatErrorMode errorMode = ConcatErrorMode.Immediate)
        {
            return new PublisherConcatMap<T, R>(source, mapper, prefetch, errorMode);
        }

        /// <summary>
        /// Concatenates IEnumerable sequences generated by a mapper function from the values of the source IPublisher.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="R">The result value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="mapper">The function that maps each source value into an IEnumerable.</param>
        /// <param name="errorMode">Specifies the error handling behavior. See <see cref="ConcatErrorMode"/> constants.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> ConcatMap<T, R>(this IFlux<T> source, Func<T, IEnumerable<R>> mapper, ConcatErrorMode errorMode = ConcatErrorMode.Immediate)
        {
            return ConcatMap(source, mapper, BufferSize, errorMode);
        }

        /// <summary>
        /// Concatenates IEnumerable sequences generated by a mapper function from the values of the source IPublisher.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="R">The result value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="mapper">The function that maps each source value into an IEnumerable.</param>
        /// <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <param name="errorMode">Specifies the error handling behavior. See <see cref="ConcatErrorMode"/> constants.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> ConcatMap<T, R>(this IFlux<T> source, Func<T, IEnumerable<R>> mapper, int prefetch, ConcatErrorMode errorMode = ConcatErrorMode.Immediate)
        {
            // TODO implement ConcatMap
            throw new NotImplementedException();
        }

        /// <summary>
        /// Concatenates the source IFlux sequence with the other IPublisher sequence, optionally delaying an OnError signal
        /// from the first one until the other sequence terminates.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="other">The other IPublisher sequence</param>
        /// <param name="delayError">If true, OnError signals are delayed until the other IPublisher sequence terminates.
        /// If both signal an OnError, the sequence signals an AggregateException of the two Exceptions.</param>
        /// <returns></returns>
        public static IFlux<T> ConcatWith<T>(this IFlux<T> source, IFlux<T> other, bool delayError = false)
        {
            if (source is PublisherConcatArray<T>)
            {
                return (source as PublisherConcatArray<T>).EndWith(source, delayError);
            }
            return new PublisherConcatArray<T>(new IPublisher<T>[] { source, other }, delayError);
        }

        /// <summary>
        /// Counts the number if elements in the IFlux sequence.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <returns>The new IMono instance.</returns>
        public static IMono<long> Count<T>(this IFlux<T> source)
        {
            return new PublisherCount<T>(source);
        }

        /// <summary>
        /// Signals a default value if the source IFlux sequence is empty.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="defaultValue">The default value to signal.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> DefaultIfEmpty<T>(this IFlux<T> source, T defaultValue)
        {
            // TODO implement DefaultIfEmpty
            throw new NotImplementedException();
        }

        /// <summary>
        /// Shifts the emission of the source IPublisher signals in time by the given amount,
        /// determined by the default timed scheduler.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="delay">The shift amount.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Delay<T>(this IFlux<T> source, TimeSpan delay)
        {
            // TODO implement Delay
            throw new NotImplementedException();
        }

        /// <summary>
        /// Shifts the emission of the source IPublisher signals in time by the given amount,
        /// determined by the given timed scheduler.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="delay">The shift amount.</param>
        /// <param name="scheduler">The timed scheduler to use for the time shifting.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Delay<T>(this IFlux<T> source, TimeSpan delay, TimedScheduler scheduler)
        {
            // TODO implement Delay
            throw new NotImplementedException();
        }

        /// <summary>
        /// Delays the actual subscription to the source IFlux instance until the specified delay
        /// has elapsed, as determined by the default timed scheduler.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="delay">The delay amount</param>
        /// <returns>The new IFlux instance</returns>
        public static IFlux<T> DelaySubscription<T>(this IFlux<T> source, TimeSpan delay)
        {
            // TODO implement DelaySubscription
            throw new NotImplementedException();
        }

        /// <summary>
        /// Delays the actual subscription to the source IFlux instance until the specified delay
        /// has elapsed, as determined by the given timed scheduler.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="delay">The delay amount</param>
        /// <param name="scheduler">The timed scheduler to use for the time shifting.</param>
        /// <returns>The new IFlux instance</returns>
        public static IFlux<T> DelaySubscription<T>(this IFlux<T> source, TimeSpan delay, TimedScheduler scheduler)
        {
            // TODO implement DelaySubscription
            throw new NotImplementedException();
        }

        /// <summary>
        /// Delays the actual subscription to the source IFlux until the other IPublisher signals an
        /// OnNext or OnComplete.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="U">The other value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="other">The other IPublisher which should trigger the actual subscription.</param>
        /// <returns></returns>
        public static IFlux<T> DelaySubscription<T, U>(this IFlux<T> source, IPublisher<U> other)
        {
            // TODO implement DelaySubscription
            throw new NotImplementedException();
        }

        /// <summary>
        /// Transforms a sequence of ISignal instances back into OnNext, OnError and OnComplete signals.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux with ISignal type.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Dematerialize<T>(this IFlux<ISignal<T>> source)
        {
            // TODO implement Dematerialize
            throw new NotImplementedException();
        }

        /// <summary>
        /// Makes sure only distinct elements are relayed through the lifetime of the IFlux sequence,
        /// as determined by the default <see cref="EqualityComparer{T}.Default"/> comparer.
        /// </summary>
        /// <remarks>
        /// Note that the internal HashSet used for remembering seen elements can't be cleared
        /// and may grow indefinitely.
        /// </remarks>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Distinct<T>(this IFlux<T> source)
        {
            return Distinct(source, v => v, EqualityComparer<T>.Default);
        }

        /// <summary>
        /// Makes sure only distinct elements are relayed through the lifetime of the IFlux sequence,
        /// as determined by the given comparer.
        /// </summary>
        /// <remarks>
        /// Note that the internal HashSet used for remembering seen elements can't be cleared
        /// and may grow indefinitely.
        /// </remarks>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="comparer">The comparer comparing the source elements</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Distinct<T>(this IFlux<T> source, IEqualityComparer<T> comparer)
        {
            return Distinct(source, v => v, comparer);
        }

        /// <summary>
        /// Makes sure only distinct elements (according to a key) are relayed through the lifetime of the IFlux sequence,
        /// as determined by the <see cref="EqualityComparer{T}.Default"/> key comparer.
        /// </summary>
        /// <remarks>
        /// Note that the internal HashSet used for remembering seen keys can't be cleared
        /// and may grow indefinitely.
        /// </remarks>
        /// <typeparam name="T">The value type.</typeparam>
        /// <typeparam name="K">The key type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="keySelector">The function that extracts the key from the source value to be checked for distinctness.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Distinct<T, K>(this IFlux<T> source, Func<T, K> keySelector)
        {
            return Distinct(source, keySelector, EqualityComparer<K>.Default);
        }

        /// <summary>
        /// Makes sure only distinct elements (according to a key) are relayed through the lifetime of the IFlux sequence,
        /// as determined by the given comparer. default <see cref="EqualityComparer{T}.Default"/> comparer.
        /// </summary>
        /// <remarks>
        /// Note that the internal HashSet used for remembering seen keys can't be cleared
        /// and may grow indefinitely.
        /// </remarks>
        /// <typeparam name="T">The value type.</typeparam>
        /// <typeparam name="K">The key type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="keySelector">The function that extracts the key from the source value to be checked for distinctness.</param>
        /// <param name="comparer">The comparer comparing the extracted keys.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Distinct<T, K>(this IFlux<T> source, Func<T, K> keySelector, IEqualityComparer<K> comparer)
        {
            return new PublisherDistinct<T, K>(source, keySelector, comparer);
        }

        /// <summary>
        /// Makes sure a source IFlux item is only relayed if it doesn't equal to the previous
        /// element, based on the default <see cref="EqualityComparer{T}.Default"/> comparer.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> DistinctUntilChanged<T>(this IFlux<T> source)
        {
            return DistinctUntilChanged(source, v => v, EqualityComparer<T>.Default);
        }

        /// <summary>
        /// Makes sure a source IFlux item is only relayed if it doesn't equal to the previous
        /// element, based on the give comparer.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="comparer">The comparer to compare subsequent source items.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> DistinctUntilChanged<T>(this IFlux<T> source, IEqualityComparer<T> comparer)
        {
            return DistinctUntilChanged(source, v => v, comparer);
        }

        /// <summary>
        /// Makes sure a source IFlux item is only relayed if the key extracted from it doesn't equal to the previous
        /// element's key, based on the default <see cref="EqualityComparer{T}.Default"/> key comparer.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="K">The key type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="keySelector">The function that extracts a key from the source item.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> DistinctUntilChanged<T, K>(this IFlux<T> source, Func<T, K> keySelector)
        {
            return DistinctUntilChanged(source, keySelector, EqualityComparer<K>.Default);
        }

        /// <summary>
        /// Makes sure a source IFlux item is only relayed if the key extracted from it doesn't equal to the previous
        /// element's key, based on the given key comparer.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="K">The key type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="keySelector">The function that extracts a key from the source item.</param>
        /// <param name="comparer">The comparer to compare the extracted keys of subsequent source items.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> DistinctUntilChanged<T, K>(this IFlux<T> source, Func<T, K> keySelector, IEqualityComparer<K> comparer)
        {
            return new PublisherDistinctUntilChanged<T, K>(source, keySelector, comparer);
        }

        /// <summary>
        /// Call the specified action after the source has signalled an OnError or OnComplete.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="onAfterTerminate">The action to call.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> DoAfterTerminate<T>(this IFlux<T> source, Action onAfterTerminate)
        {
            return PublisherPeek<T>.withOnAfterTerminate(source, onAfterTerminate);
        }

        /// <summary>
        /// Call the specified action with the current value after the source has signalled an OnNext.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="onAfterNext">The action to call.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> DoAfterNext<T>(this IFlux<T> source, Action<T> onAfterNext)
        {
            return PublisherPeek<T>.withOnAfterNext(source, onAfterNext);
        }

        /// <summary>
        /// Call the specified action if the sequence gets cancelled.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="onCancel">The action to call.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> DoOnCancel<T>(this IFlux<T> source, Action onCancel)
        {
            return PublisherPeek<T>.withOnCancel(source, onCancel);
        }

        /// <summary>
        /// Call the specified action before the source signals an OnComplete.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="onComplete">The action to call.</param>
        /// <returns>The new IFlux instance.</returns>

        public static IFlux<T> DoOnComplete<T>(this IFlux<T> source, Action onComplete)
        {
            return PublisherPeek<T>.withOnComplete(source, onComplete);
        }

        /// <summary>
        /// Call the specified action before the source signals an OnError.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="onError">The action to call.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> DoOnError<T>(this IFlux<T> source, Action<Exception> onError)
        {
            return PublisherPeek<T>.withOnError(source, onError);
        }

        /// <summary>
        /// Call the specified action before the source signals OnError with the given Exception type (or its subtypes).
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <typeparam name="E">The exception type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="onError">The action to call.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> DoOnError<T, E>(this IFlux<T> source, Action<E> onError) where E : Exception
        {
            return DoOnError(source, e =>
            {
                if (e is E)
                {
                    onError(e as E);
                }
            });
        }

        /// <summary>
        /// Call the specified action before the source signals an OnError whose Exception matches the predicate.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="predicate">The predicate that receives the Exception and if returns true, the onError action is called.</param>
        /// <param name="onError">The action to call.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> DoOnError<T>(this IFlux<T> source, Func<Exception, bool> predicate, Action<Exception> onError)
        {
            return DoOnError(source, e =>
            {
                if (predicate(e))
                {
                    onError(e);
                }
            });
        }

        /// <summary>
        /// Calls the specified action with the current value before the sequence signals an OnNext.
        /// </summary>
        /// <typeparam name="T">The value type</typeparam>
        /// <param name="source">The source IFlux</param>
        /// <param name="onNext">The action to call with the current value.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> DoOnNext<T>(this IFlux<T> source, Action<T> onNext)
        {
            return PublisherPeek<T>.withOnNext(source, onNext);
        }

        /// <summary>
        /// Calls the specified action with the current request amount before it reaches the upstream.
        /// </summary>
        /// <typeparam name="T">The value type</typeparam>
        /// <param name="source">The source IFlux</param>
        /// <param name="onRequest">The action to call.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> DoOnRequest<T>(this IFlux<T> source, Action<long> onRequest)
        {
            return PublisherPeek<T>.withOnRequest(source, onRequest);
        }

        /// <summary>
        /// Calls the specified action with the incoming ISubscription before it reaches the downstream.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="onSubscribe">The action to call.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> DoOnSubscribe<T>(this IFlux<T> source, Action<ISubscription> onSubscribe)
        {
            return PublisherPeek<T>.withOnSubscribe(source, onSubscribe);
        }

        /// <summary>
        /// Calls the specified action befoer the source signals an OnError or OnComplete.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="onTerminate">The action to call.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> DoOnTerminate<T>(this IFlux<T> source, Action onTerminate)
        {
            return PublisherPeek<T>.withOnTerminate(source, onTerminate);
        }

        /// <summary>
        /// Wraps each source element into a Timed structure which holds the time difference between
        /// subsequent element according to the default timed scheduler. The first structure holds
        /// the time between the subscription and the emission of the first element.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<Timed<T>> Elapsed<T>(this IFlux<T> source)
        {
            return Elapsed(source, DefaultScheduler.Instance);
        }

        /// <summary>
        /// Wraps each source element into a Timed structure which holds the time difference between
        /// subsequent element according to the given timed scheduler. The first structure holds
        /// the time between the subscription and the emission of the first element.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="scheduler">The scheduler supplying the notion of current time.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<Timed<T>> Elapsed<T>(this IFlux<T> source, TimedScheduler scheduler)
        {
            // TODO implement Elapsed
            throw new NotImplementedException();
        }

        /// <summary>
        /// Emits the element at the given index or signals an IndexOutOfRangeException if
        /// the sequence is shorter.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="index">The index of the element to return.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IMono<T> ElementAt<T>(this IFlux<T> source, long index)
        {
            // TODO implement ElementAt
            throw new NotImplementedException();
        }

        /// <summary>
        /// Emits the element at the given index or signals a default value if
        /// the sequence is shorter.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="index">The index of the element to return.</param>
        /// <param name="defaultValue">The value to signal if the sequence is shorter.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IMono<T> ElementAt<T>(this IFlux<T> source, long index, T defaultValue)
        {
            // TODO implement ElementAt
            throw new NotImplementedException();
        }

        /// <summary>
        /// Returns every <paramref name="batchSize"/> element from the source sequence
        /// or the very last element (if the source length not multiple of the batchSize).
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="batchSize">The frequency of elements to return.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Every<T>(this IFlux<T> source, int batchSize)
        {
            return source.Window(batchSize).FlatMap(w => w.Last());
        }

        /// <summary>
        /// Returns every <paramref name="batchSize"/> element, starting from the first element from
        /// the source sequence.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="batchSize">The frequency of elements to return.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> EveryFirst<T>(this IFlux<T> source, int batchSize)
        {
            return source.Window(batchSize).FlatMap(w => w.Next());
        }

        /// <summary>
        /// Filters out elements that don't match the predicate.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux</param>
        /// <param name="predicate">The predicate function called for each source element and returns true if that element
        /// may pass.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Filter<T>(this IFlux<T> source, Func<T, bool> predicate)
        {
            return new PublisherFilter<T>(source, predicate);
        }

        /// <summary>
        /// Relays signals of the source IFlux or the other IPublisher sequence whichever signals first,
        /// cancelling the other (or not even subscribing to it).
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="other">The other IPublisher.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> FirstEmittingWith<T>(this IFlux<T> source, IPublisher<T> other)
        {
            if (source is PublisherAmb<T>)
            {
                var a = (source as PublisherAmb<T>).AmbWith(other);
                if (a != null)
                {
                    return a;
                }
            }
            return FirstEmitting<T>(source, other);
        }

        /// <summary>
        /// Flattens (merges) a sequence of IPublisher sources generated via a mapper function from the source elements, optionally
        /// delaying any errors.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="R">The result value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="mapper">The function that receives a source value and returns an IPublisher to be merged</param>
        /// <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
        /// signalling an AggregateException if there were more than one Exception.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> FlatMap<T, R>(this IFlux<T> source, Func<T, IPublisher<R>> mapper, bool delayErrors = false)
        {
            return FlatMap(source, mapper, BufferSize, BufferSize, delayErrors);
        }

        /// <summary>
        /// Flattens (merges) a sequence of IPublisher sources generated via a mapper function from the source elements, 
        /// making sure only the specified number of sources are active and optionally
        /// delaying any errors.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="R">The result value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="mapper">The function that receives a source value and returns an IPublisher to be merged</param>
        /// <param name="maxConcurrency">The maximum number of active IPublisher sources at the same time.</param>
        /// <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
        /// signalling an AggregateException if there were more than one Exception.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> FlatMap<T, R>(this IFlux<T> source, Func<T, IPublisher<R>> mapper, int maxConcurrency, bool delayErrors = false)
        {
            return FlatMap(source, mapper, maxConcurrency, BufferSize, delayErrors);
        }

        /// <summary>
        /// Flattens (merges) a sequence of IPublisher sources generated via a mapper function from the source elements, 
        /// making sure only the specified number of sources are active, prefetching the specified amount from each
        /// and optionally delaying any errors.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="R">The result value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="mapper">The function that receives a source value and returns an IPublisher to be merged</param>
        /// <param name="maxConcurrency">The maximum number of active IPublisher sources at the same time.</param>
        /// <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
        /// signalling an AggregateException if there were more than one Exception.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> FlatMap<T, R>(this IFlux<T> source, Func<T, IPublisher<R>> mapper, int maxConcurrency, int prefetch, bool delayErrors = false)
        {
            return new PublisherFlatMap<T, R>(source, mapper, delayErrors, maxConcurrency, prefetch);
        }


        /// <summary>
        /// Flattens (merges) a sequence of IPublisher sources generated via a mapper function from the source elements and terminal signals.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="R">The result value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="mapperOnNext">The function that receives each source elements and returns an IPublisher for them to be merged.</param>
        /// <param name="mapperOnError">The function that receives the Exception and returns an IPublisher for it to be merged.</param>
        /// <param name="mapperOnComplete">The function that is called when the source completes and returns an IPublisher for it to be merged.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> FlatMap<T, R>(this IFlux<T> source, Func<T, IPublisher<R>> mapperOnNext, 
            Func<Exception, IPublisher<R>> mapperOnError, Func<IPublisher<R>> mapperOnComplete)
        {
            // TODO implement FlatMap
            throw new NotImplementedException();
        }

        /// <summary>
        /// Flattens (merges) IEnumerable sequences generated by a mapper function from the values of the source IPublisher.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="R">The result value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="mapper">The function that maps each source value into an IEnumerable.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> FlatMap<T, R>(this IFlux<T> source, Func<T, IEnumerable<R>> mapper)
        {
            // TODO implement FlatMap
            throw new NotImplementedException();
        }

        /// <summary>
        /// Flattens (merges) IEnumerable sequences generated by a mapper function from the values of the source IPublisher.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="R">The result value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="mapper">The function that maps each source value into an IEnumerable.</param>
        /// <param name="prefetch">The number of items to prefetch from the source. If negative, the source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> FlatMap<T, R>(this IFlux<T> source, Func<T, IEnumerable<R>> mapper, int prefetch)
        {
            // TODO implement FlatMap
            throw new NotImplementedException();
        }

        /// <summary>
        /// Groups elements with the same key into an IGroupedFlux inner sequences.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="K">The key type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="keySelector">The function that extracts a key from a source element.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<IGroupedFlux<K, T>> GroupBy<T, K>(this IFlux<T> source, Func<T, K> keySelector)
        {
            return GroupBy(source, keySelector, v => v, BufferSize);
        }

        /// <summary>
        /// Groups values, extracted from elements, with the same key into IGroupedFlux inner sequences.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="K">The key type.</typeparam>
        /// <typeparam name="V">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="keySelector">The function that extracts a key from a source element.</param>
        /// <param name="valueSelector">The function that extracts the value from a source element.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<IGroupedFlux<K, V>> GroupBy<T, K, V>(this IFlux<T> source, Func<T, K> keySelector, Func<T, V> valueSelector)
        {
            return GroupBy(source, keySelector, valueSelector, BufferSize);
        }

        /// <summary>
        /// Groups values, extracted from elements, with the same key into IGroupedFlux inner sequences.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="K">The key type.</typeparam>
        /// <typeparam name="V">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="keySelector">The function that extracts a key from a source element.</param>
        /// <param name="valueSelector">The function that extracts the value from a source element.</param>
        /// <param name="prefetch">The number of items to prefetch from the source. If negative, the source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<IGroupedFlux<K, V>> GroupBy<T, K, V>(this IFlux<T> source, Func<T, K> keySelector, Func<T, V> valueSelector, int prefetch)
        {
            // TODO implement GroupBy
            throw new NotImplementedException();
        }

        /// <summary>
        /// Signals a single true if the source has the specified element, based on
        /// the <see cref="EqualityComparer{T}.Default"/> comparer.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="element">The element to look for.</param>
        /// <returns>The new IMono instance</returns>
        public static IMono<bool> HasElement<T>(this IFlux<T> source, T element)
        {
            return HasElement(source, element, EqualityComparer<T>.Default);
        }

        /// <summary>
        /// Signals a single true if the source has the specified element, based on
        /// the given comparer.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="element">The element to look for.</param>
        /// <param name="comparer">The comparer to use to compare source elements with the given element.</param>
        /// <returns>The new IMono instance</returns>
        public static IMono<bool> HasElement<T>(this IFlux<T> source, T element, IEqualityComparer<T> comparer)
        {
            return Any(source, v => comparer.Equals(v, element));
        }

        /// <summary>
        /// Signals a single true if the source IFlux sequence contains any elements (i.e., it's not empty).
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <returns>The new IMono instance.</returns>
        public static IMono<bool> HasElements<T>(this IFlux<T> source)
        {
            // TODO implement HasElements
            throw new NotImplementedException();
        }

        /// <summary>
        /// Hides the external and internal identity of the source sequence; useful
        /// to break identity based macro- and micro-optimizations.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Hide<T>(this IFlux<T> source)
        {
            return new PublisherHide<T>(source);
        }

        /// <summary>
        /// Ignores OnNext signals from the source and only relays the terminal signals.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <param name="source">The source IFlux to ignore elements of.</param>
        /// <returns>The new IMono instance.</returns>
        public static IMono<T> IgnoreElements<T>(this IFlux<T> source)
        {
            return new PublisherIgnoreElements<T>(source);
        }

        /// <summary>
        /// Returns the last element from the source sequence or signal IndexOutOfRangeException.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <returns>The new IMono instance.</returns>
        public static IMono<T> Last<T>(this IFlux<T> source)
        {
            // TODO implement Last
            throw new NotImplementedException();
        }

        public static IFlux<T> MapError<T>(this IFlux<T> source, Func<Exception, Exception> mapper)
        {
            return MapError(source, e => true, mapper);
        }

        public static IFlux<T> MapError<T, E>(this IFlux<T> source, Func<E, Exception> mapper) where E : Exception
        {
            return MapError(source, e => e is E, e => mapper(e as E));
        }

        public static IFlux<T> MapError<T>(this IFlux<T> source, Func<Exception, bool> predicate, Func<Exception, Exception> mapper)
        {
            // TODO implement MapError
            throw new NotImplementedException();
        }

        public static IFlux<ISignal<T>> Materialize<T>(this IFlux<T> source)
        {
            // TODO implement Materialize
            throw new NotImplementedException();
        }

        public static IFlux<T> MergeWith<T>(this IFlux<T> source, IFlux<T> other)
        {
            // TODO implement MergeWith
            throw new NotImplementedException();
        }

        public static IFlux<R> Multiplex<T, R>(this IFlux<T> source, int concurrency, Func<IGroupedFlux<int, T>, IPublisher<R>> mapper)
        {
            // TODO implement Multiplex
            throw new NotImplementedException();
        }

        public static IMono<IFlux<T>> Nest<T>(this IFlux<T> source)
        {
            return Mono.Just(source);
        }

        public static IMono<T> Next<T>(this IFlux<T> source)
        {
            // TODO implement Last
            throw new NotImplementedException();
        }

        public static IFlux<T> OnBackpressureBuffer<T>(this IFlux<T> source)
        {
            // TODO implement OnBackpressureBuffer
            throw new NotImplementedException();
        }

        public static IFlux<T> OnBackpressureDrop<T>(this IFlux<T> source, Action<T> onDrop = null)
        {
            // TODO implement OnBackpressureDrop
            throw new NotImplementedException();
        }

        public static IFlux<T> OnBackpressureError<T>(this IFlux<T> source)
        {
            return OnBackpressureDrop(source, e => { throw BackpressureHelper.MissingBackpressureException(); });
        }

        public static IFlux<T> OnBackpressureLatest<T>(this IFlux<T> source)
        {
            // TODO implement OnBackpressureLatest
            throw new NotImplementedException();
        }

        public static IFlux<T> OnErrorResumeWith<T>(this IFlux<T> source, Func<Exception, IPublisher<T>> resumeFunction)
        {
            return OnErrorResumeWith(source, e => true, resumeFunction);
        }

        public static IFlux<T> OnErrorResumeWith<T, E>(this IFlux<T> source, Func<E, IPublisher<T>> resumeFunction) where E : Exception
        {
            return OnErrorResumeWith(source, e => e is E, e => resumeFunction(e as E));
        }

        public static IFlux<T> OnErrorResumeWith<T>(this IFlux<T> source, Func<Exception, bool> predicate, Func<Exception, IPublisher<T>> resumeFunction)
        {
            // TODO implement OnErrorResumeWith
            throw new NotImplementedException();
        }

        public static IFlux<T> OnErrorReturn<T>(this IFlux<T> source, T value)
        {
            return OnErrorReturn(source, e => true, value);
        }

        public static IFlux<T> OnErrorReturn<T, E>(this IFlux<T> source, T value) where E : Exception
        {
            return OnErrorReturn(source, e => e is E, value);
        }

        public static IFlux<T> OnErrorReturn<T>(this IFlux<T> source, Func<Exception, bool> predicate, T value)
        {
            // TODO implement OnErrorReturn
            throw new NotImplementedException();
        }

        public static IFlux<T> OnTerminateDetach<T>(this IFlux<T> source)
        {
            // TODO implement OnTerminateDetach
            throw new NotImplementedException();
        }

        public static IFlux<IGroupedFlux<int, T>> Partition<T>(this IFlux<T> source)
        {
            return Partition(source, Environment.ProcessorCount);
        }

        public static IFlux<IGroupedFlux<int, T>> Partition<T>(this IFlux<T> source, int partitions)
        {
            // TODO implement Partition
            throw new NotImplementedException();
        }

        public static IConnectableFlux<T> Process<T>(this IFlux<T> source, IProcessor<T, T> processor)
        {
            return Process(source, () => processor);
        }

        public static IConnectableFlux<T> Process<T>(this IFlux<T> source, Func<IProcessor<T, T>> processorSupplier)
        {
            // TODO implement Process
            throw new NotImplementedException();
        }

        public static IConnectableFlux<T> Process<T, U>(this IFlux<T> source, IProcessor<T, T> processor, Func<IFlux<T>, IPublisher<U>> selector)
        {
            return Process(source, () => processor, selector);
        }

        public static IConnectableFlux<T> Process<T, U>(this IFlux<T> source, Func<IProcessor<T, T>> processorSupplier, Func<IFlux<T>, IPublisher<U>> selector)
        {
            // TODO implement Process
            throw new NotImplementedException();
        }

        public static IConnectableFlux<T> Publish<T>(this IFlux<T> source)
        {
            return Publish(source, BufferSize);
        }

        public static IConnectableFlux<T> Publish<T>(this IFlux<T> source, int prefetch)
        {
            // TODO implement Publish
            throw new NotImplementedException();
        }

        public static IFlux<R> Publish<T, R>(this IFlux<T> source, Func<IFlux<T>, IPublisher<R>> transformer)
        {
            return Publish<T, R>(source, transformer, BufferSize);
        }

        public static IFlux<R> Publish<T, R>(this IFlux<T> source, Func<IFlux<T>, IPublisher<R>> transformer, int prefetch)
        {
            // TODO implement Publish
            throw new NotImplementedException();
        }

        public static IMono<T> PublishNext<T>(this IFlux<T> source)
        {
            // TODO implement PublishNext
            throw new NotImplementedException();
        }

        public static IFlux<T> PublishOn<T>(this IFlux<T> source, Scheduler scheduler, bool delayError = true)
        {
            return PublishOn(source, scheduler, BufferSize, delayError);
        }

        public static IFlux<T> PublishOn<T>(this IFlux<T> source, Scheduler scheduler, int prefetch, bool delayError = true)
        {
            return new PublisherPublishOn<T>(source, scheduler, delayError, prefetch);
        }

        public static IFlux<T> Reduce<T>(this IFlux<T> source, Func<T, T, T> reducer)
        {
            // TODO implement Reduce
            throw new NotImplementedException();
        }

        public static IFlux<A> Reduce<T, A>(this IFlux<T> source, A initial, Func<A, T, A> reducer)
        {
            // TODO implement Reduce
            throw new NotImplementedException();
        }

        public static IFlux<A> ReduceWith<T, A>(this IFlux<T> source, Func<A> initialSupplier, Func<A, T, A> reducer)
        {
            // TODO implement ReduceWith
            throw new NotImplementedException();
        }

        public static IFlux<T> Repeat<T>(this IFlux<T> source)
        {
            // TODO implement Repeat
            throw new NotImplementedException();
        }

        public static IFlux<T> Repeat<T>(this IFlux<T> source, long times)
        {
            // TODO implement Repeat
            throw new NotImplementedException();
        }

        public static IFlux<T> Repeat<T>(this IFlux<T> source, Func<bool> predicate)
        {
            // TODO implement Repeat
            throw new NotImplementedException();
        }

        public static IFlux<T> Repeat<T>(this IFlux<T> source, long times, Func<bool> predicate)
        {
            // TODO implement Repeat
            throw new NotImplementedException();
        }

        public static IFlux<T> RepeatWhen<T>(this IFlux<T> source, Func<IFlux<long>, IPublisher<object>> whenFunction)
        {
            // TODO implement RepeatWhen
            throw new NotImplementedException();
        }

        public static IConnectableFlux<T> Replay<T>(this IFlux<T> source)
        {
            // TODO implement Replay
            throw new NotImplementedException();
        }

        public static IConnectableFlux<T> Replay<T>(this IFlux<T> source, int history)
        {
            // TODO implement Replay
            throw new NotImplementedException();
        }

        public static IFlux<R> Replay<T, R>(this IFlux<T> source, Func<IFlux<T>, IPublisher<R>> transformer)
        {
            // TODO implement Replay
            throw new NotImplementedException();
        }

        public static IFlux<T> Retry<T>(this IFlux<T> source)
        {
            // TODO implement Retry
            throw new NotImplementedException();
        }

        public static IFlux<T> Retry<T>(this IFlux<T> source, long times)
        {
            // TODO implement Retry
            throw new NotImplementedException();
        }

        public static IFlux<T> Retry<T>(this IFlux<T> source, Func<Exception> predicate)
        {
            // TODO implement Retry
            throw new NotImplementedException();
        }

        public static IFlux<T> Retry<T>(this IFlux<T> source, long times, Func<Exception> predicate)
        {
            // TODO implement Retry
            throw new NotImplementedException();
        }

        public static IFlux<T> RetryWhen<T>(this IFlux<T> source, Func<IFlux<Exception>, IPublisher<object>> whenFunction)
        {
            // TODO implement RepeatWhen
            throw new NotImplementedException();
        }

        public static IFlux<T> Sample<T>(this IFlux<T> source, TimeSpan timespan)
        {
            return Sample(source, timespan, DefaultScheduler.Instance);
        }

        public static IFlux<T> Sample<T>(this IFlux<T> source, TimeSpan timespan, TimedScheduler scheduler)
        {
            // TODO implement Sample
            throw new NotImplementedException();
        }

        public static IFlux<T> Sample<T, U>(this IFlux<T> source, IPublisher<U> sampler)
        {
            // TODO implement Sample
            throw new NotImplementedException();
        }

        public static IFlux<T> SampleFirst<T>(this IFlux<T> source, TimeSpan timespan)
        {
            return SampleFirst(source, timespan, DefaultScheduler.Instance);
        }

        public static IFlux<T> SampleFirst<T>(this IFlux<T> source, TimeSpan timespan, TimedScheduler scheduler)
        {
            // TODO implement Sample
            throw new NotImplementedException();
        }

        public static IFlux<T> SampleFirst<T, U>(this IFlux<T> source, Func<T, IPublisher<U>> samplerFactory)
        {
            // TODO implement Sample
            throw new NotImplementedException();
        }

        public static IFlux<T> SampleTimeout<T>(this IFlux<T> source, TimeSpan timespan)
        {
            return SampleTimeout(source, timespan, DefaultScheduler.Instance);
        }

        public static IFlux<T> SampleTimeout<T>(this IFlux<T> source, TimeSpan timespan, TimedScheduler scheduler)
        {
            // TODO implement Sample
            throw new NotImplementedException();
        }

        public static IFlux<T> SampleTimeout<T, U>(this IFlux<T> source, Func<T, IPublisher<U>> samplerFactory)
        {
            // TODO implement Sample
            throw new NotImplementedException();
        }

        public static IFlux<T> SampleTimeout<T, U>(this IFlux<T> source, Func<T, IPublisher<U>> samplerFactory, int maxConcurrency)
        {
            // TODO implement Sample
            throw new NotImplementedException();
        }

        public static IFlux<T> Scan<T>(this IFlux<T> source, Func<T, T, T> scanner)
        {
            // TODO implement Reduce
            throw new NotImplementedException();
        }

        public static IFlux<A> Scan<T, A>(this IFlux<T> source, A initial, Func<A, T, A> scanner)
        {
            // TODO implement Reduce
            throw new NotImplementedException();
        }

        public static IFlux<A> ScanWith<T, A>(this IFlux<T> source, Func<A> initialSupplier, Func<A, T, A> scanner)
        {
            // TODO implement ReduceWith
            throw new NotImplementedException();
        }

        public static IMono<T> Single<T>(this IFlux<T> source)
        {
            // TODO implement Single
            throw new NotImplementedException();
        }

        public static IMono<T> Single<T>(this IFlux<T> source, T defaultValue)
        {
            // TODO implement Single
            throw new NotImplementedException();
        }

        public static IMono<T> SingleOrEmpty<T>(this IFlux<T> source)
        {
            // TODO implement Single
            throw new NotImplementedException();
        }

        public static IFlux<T> Skip<T>(this IFlux<T> source, long n)
        {
            if (n <= 0L)
            {
                return source;
            }
            return new PublisherSkip<T>(source, n);
        }

        public static IFlux<T> Skip<T>(this IFlux<T> source, TimeSpan timespan)
        {
            return Skip(source, timespan, DefaultScheduler.Instance);
        }

        public static IFlux<T> Skip<T>(this IFlux<T> source, TimeSpan timespan, TimedScheduler scheduler)
        {
            // TODO implement Skip
            throw new NotImplementedException();
        }

        public static IFlux<T> SkipLast<T>(this IFlux<T> source, long n)
        {
            // TODO implement SkipLast
            throw new NotImplementedException();
        }

        public static IFlux<T> SkipUntil<T, U>(this IFlux<T> source, IPublisher<U> other)
        {
            // TODO implement SkipUntil
            throw new NotImplementedException();
        }

        public static IFlux<T> SkipWhile<T, U>(this IFlux<T> source, Func<T, bool> predicate)
        {
            // TODO implement SkipWhile
            throw new NotImplementedException();
        }

        public static IFlux<T> StartWith<T>(this IFlux<T> source, bool delayError = false, params T[] values)
        {
            return StartWith<T>(source, From(values), delayError);
        }

        public static IFlux<T> StartWith<T>(this IFlux<T> source, IEnumerable<T> values, bool delayError = false)
        {
            return StartWith<T>(source, From(values), delayError);
        }

        public static IFlux<T> StartWith<T>(this IFlux<T> source, IPublisher<T> other, bool delayError = false)
        {
            if (source is PublisherConcatArray<T>)
            {
                return (source as PublisherConcatArray<T>).StartWith(source, delayError);
            }
            return new PublisherConcatArray<T>(new IPublisher<T>[] { source, other }, delayError);
        }

        public static IFlux<T> SubscribeOn<T>(this IFlux<T> source, Scheduler scheduler)
        {
            // TODO implement SubscribeOn
            throw new NotImplementedException();
        }

        public static IFlux<R> SwitchMap<T, R>(this IFlux<T> source, Func<T, IPublisher<R>> mapper)
        {
            return SwitchMap(source, mapper, BufferSize);
        }

        public static IFlux<R> SwitchMap<T, R>(this IFlux<T> source, Func<T, IPublisher<R>> mapper, int prefetch)
        {
            return new PublisherSwitchMap<T, R>(source, mapper, prefetch);
        }

        public static IFlux<T> SwitchIfEmpty<T>(this IFlux<T> source, IFlux<T> other)
        {
            // TODO implement SwitchIfEmpty
            throw new NotImplementedException();
        }

        public static IFlux<T> Take<T>(this IFlux<T> source, long n)
        {
            return new PublisherTake<T>(source, n);
        }

        public static IFlux<T> Take<T>(this IFlux<T> source, TimeSpan timespan)
        {
            return Take(source, timespan);
        }

        public static IFlux<T> Take<T>(this IFlux<T> source, TimeSpan timespan, TimedScheduler scheduler)
        {
            // TODO implement Take
            throw new NotImplementedException();
        }

        public static IFlux<T> TakeLast<T>(this IFlux<T> source, long n)
        {
            // TODO implement TakeLast
            throw new NotImplementedException();
        }

        public static IFlux<T> TakeUntil<T, U>(this IFlux<T> source, IPublisher<U> other)
        {
            // TODO implement TakeUntil
            throw new NotImplementedException();
        }

        public static IFlux<T> TakeUntil<T>(this IFlux<T> source, Func<T, bool> predicate)
        {
            // TODO implement TakeUntil
            throw new NotImplementedException();
        }

        public static IFlux<T> TakeWhile<T>(this IFlux<T> source, Func<T, bool> predicate)
        {
            // TODO implement TakeWhile
            throw new NotImplementedException();
        }

        public static IMono<T> Then<T>(this IFlux<T> source)
        {
            // TODO implement Then
            throw new NotImplementedException();
        }

        public static IMono<Void> Then<T>(this IFlux<T> source, IPublisher<Void> other)
        {
            // TODO implement Then
            throw new NotImplementedException();
        }

        public static IMono<Void> Then<T>(this IFlux<T> source, Func<IPublisher<Void>> afterSupplier)
        {
            return Then(source, Defer(afterSupplier));
        }

        public static IFlux<T> ThenMany<T>(this IFlux<T> source, IPublisher<T> after)
        {
            // Can't fuse multiple applications into one operator unless all the types are the same due to non-erasure, unlike Java.
            return ThenMany<T, T>(source, after);
        }

        public static IFlux<R> ThenMany<T, R>(this IFlux<T> source, IPublisher<R> afterSupplier)
        {
            // TODO implement ThenMany
            throw new NotImplementedException();
        }

        public static IFlux<R> ThenMany<T, R>(this IFlux<T> source, Func<IPublisher<R>> afterSupplier)
        {
            return ThenMany<T, R>(source, Defer(afterSupplier));
        }

        public static IFlux<T> Timeout<T>(this IFlux<T> source, TimeSpan timeout, IPublisher<T> fallback = null)
        {
            return Timeout(source, timeout, DefaultScheduler.Instance);
        }

        public static IFlux<T> Timeout<T>(this IFlux<T> source, TimeSpan timeout, TimedScheduler scheduler, IPublisher<T> fallback = null)
        {
            // TODO implement Timeout
            throw new NotImplementedException();
        }


        public static IFlux<T> Timeout<T, U>(this IFlux<T> source, IPublisher<U> firstTimeout, IPublisher<T> fallback = null)
        {
            // TODO implement Timeout
            throw new NotImplementedException();
        }

        public static IFlux<T> Timeout<T, U, V>(this IFlux<T> source, IPublisher<U> firstTimeout, Func<U, IPublisher<V>> itemTimeout, IPublisher<T> fallback = null)
        {
            // TODO implement Timeout
            throw new NotImplementedException();
        }

        public static IFlux<Timed<T>> Timestamp<T>(this IFlux<T> source)
        {
            return Timestamp(source, DefaultScheduler.Instance);
        }

        public static IFlux<Timed<T>> Timestamp<T>(this IFlux<T> source, TimedScheduler scheduler)
        {
            return Map(source, v => new Timed<T>(v, scheduler.NowUtc));
        }

        public static IFlux<T> ToFlux<T>(this IObservable<T> source, BackpressureHandling backpressure = BackpressureHandling.Error)
        {
            return From(source, backpressure);
        }

        /// <summary>
        /// Converts this IFlux into an IMono.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source to convert</param>
        /// <returns>The IFlux instance</returns>
        public static IMono<T> ToMono<T>(this IFlux<T> source)
        {
            if (source is IMono<T>)
            {
                return source as IMono<T>;
            }
            // TODO implement ToMono
            throw new NotImplementedException();
        }

        /// <summary>
        /// Convert this IFlux into an IObservable.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <returns>The new IObservable.</returns>
        public static IObservable<T> ToObservable<T>(this IFlux<T> source)
        {
            return new PublisherAsObservable<T>(source);
        }

        public static IFlux<IFlux<T>> Window<T>(this IFlux<T> source)
        {
            // TODO implement Window
            throw new NotImplementedException();
        }

        public static IFlux<IFlux<T>> Window<T>(this IFlux<T> source, int size) {
            return Window(source, size, size);
        }

        public static IFlux<IFlux<T>> Window<T>(this IFlux<T> source, int size, int skip)
        {
            // TODO implement Window
            throw new NotImplementedException();
        }

        public static IFlux<IFlux<T>> Window<T, U>(this IFlux<T> source, IPublisher<U> boundary)
        {
            // TODO implement Window
            throw new NotImplementedException();
        }

        public static IFlux<IFlux<T>> Window<T, U, V>(this IFlux<T> source, IPublisher<U> open, Func<U, IPublisher<V>> close)
        {
            // TODO implement Window
            throw new NotImplementedException();
        }

        public static IFlux<IFlux<T>> Window<T>(this IFlux<T> source, TimeSpan timespan)
        {
            return Window(source, timespan, timespan, DefaultScheduler.Instance);
        }

        public static IFlux<IFlux<T>> Window<T>(this IFlux<T> source, TimeSpan timespan, TimedScheduler scheduler)
        {
            return Window(source, timespan, timespan, scheduler);
        }

        public static IFlux<IFlux<T>> Window<T>(this IFlux<T> source, TimeSpan timespan, TimeSpan timeskip)
        {
            return Window(source, timespan, timeskip, DefaultScheduler.Instance);
        }

        public static IFlux<IFlux<T>> Window<T>(this IFlux<T> source, TimeSpan timespan, TimeSpan timeskip, TimedScheduler scheduler)
        {
            // TODO implement Window
            throw new NotImplementedException();
        }

        public static IFlux<IFlux<T>> Window<T>(this IFlux<T> source, int maxSize, TimeSpan timespan)
        {
            return Window(source, maxSize, timespan, DefaultScheduler.Instance);
        }

        public static IFlux<IFlux<T>> Window<T>(this IFlux<T> source, int maxSize, TimeSpan timespan, TimedScheduler scheduler)
        {
            // TODO implement Window
            throw new NotImplementedException();
        }

        public static IFlux<R> WithLatestFrom<T1, T2, R>(this IFlux<T1> source, IPublisher<T2> other, Func<T1, T2, R> combiner)
        {
            // TODO implement WithLatestFrom
            throw new NotImplementedException();
        }

        public static IFlux<R> WithLatestFrom<T1, T2, T3, R>(this IFlux<T1> source, 
            IPublisher<T2> p2, IPublisher<T3> p3,
            Func<T1, T2, T3, R> combiner)
        {
            // TODO implement WithLatestFrom
            throw new NotImplementedException();
        }

        public static IFlux<R> WithLatestFrom<T1, T2, T3, T4, R>(this IFlux<T1> source,
            IPublisher<T2> p2, IPublisher<T3> p3,
            IPublisher<T4> p4,
            Func<T1, T2, T3, T4, R> combiner)
        {
            // TODO implement WithLatestFrom
            throw new NotImplementedException();
        }

        public static IFlux<R> WithLatestFrom<T1, T2, T3, T4, T5, R>(this IFlux<T1> source,
            IPublisher<T2> p2, IPublisher<T3> p3,
            IPublisher<T4> p4, IPublisher<T5> p5,
            Func<T1, T2, T3, T4, T5, R> combiner)
        {
            // TODO implement WithLatestFrom
            throw new NotImplementedException();
        }

        public static IFlux<R> WithLatestFrom<T1, T2, T3, T4, T5, T6, R>(this IFlux<T1> source,
            IPublisher<T2> p2, IPublisher<T3> p3,
            IPublisher<T4> p4, IPublisher<T5> p5,
            IPublisher<T6> p6,
            Func<T1, T2, T3, T4, T5, T6, R> combiner)
        {
            // TODO implement WithLatestFrom
            throw new NotImplementedException();
        }

        public static IFlux<R> WithLatestFrom<T, R>(this IFlux<T> source, Func<T[], R> combiner, params IPublisher<T>[] others)
        {
            // TODO implement WithLatestFrom
            throw new NotImplementedException();
        }

        public static IFlux<R> ZipWith<T, R>(this IFlux<T> source, IPublisher<T> other, Func<T, T, R> zipper)
        {
            return ZipWith<T, R>(source, other, zipper, BufferSize);
        }

        public static IFlux<R> ZipWith<T, R>(this IFlux<T> source, IPublisher<T> other, Func<T, T, R> zipper, int prefetch)
        {
            // Allows fusing only if all soures have the same type due to no type erasure, unlike Java
            // TODO implement ZipWith
            throw new NotImplementedException();
        }

        public static IFlux<R> ZipWith<T, U, R>(this IFlux<T> source, IPublisher<U> other, Func<T, U, R> zipper)
        {
            return ZipWith<T, U, R>(source, other, zipper, BufferSize);
        }

        public static IFlux<R> ZipWith<T, U, R>(this IFlux<T> source, IPublisher<U> other, Func<T, U, R> zipper, int prefetch)
        {
            // TODO implement ZipWith
            throw new NotImplementedException();
        }

        public static IFlux<Tuple<T, U>> ZipWith<T, U>(this IFlux<T> source, IPublisher<U> other)
        {
            return ZipWith(source, other, BufferSize);
        }

        public static IFlux<Tuple<T, U>> ZipWith<T, U>(this IFlux<T> source, IPublisher<U> other, int prefetch)
        {
            // TODO implement ZipWith
            throw new NotImplementedException();
        }

        public static IFlux<Tuple<T, U>> ZipWith<T, U>(this IFlux<T> source, IEnumerable<U> other)
        {
            return ZipWith(source, other, (a, b) => new Tuple<T, U>(a, b));
        }

        public static IFlux<R> ZipWith<T, U, R>(this IFlux<T> source, IEnumerable<U> other, Func<T, U, R> zipper)
        {
            return new PublisherZipEnumerable<T, U, R>(source, other, zipper);
        }

        // ---------------------------------------------------------------------------------------------------------
        // Leave the reactive world
        // ---------------------------------------------------------------------------------------------------------

        /// <summary>
        /// Subscribe to the source and block until it produces a value or
        /// signals an Exception. An empty source will throw an IndexOutOfRangeException.
        /// </summary>
        /// <typeparam name="T">The value type</typeparam>
        /// <param name="source">The source</param>
        /// <returns>The value produced</returns>
        /// <exception cref="IndexOutOfRangeException">If the source is empty.</exception>
        public static T BlockFirst<T>(this IFlux<T> source)
        {
            var s = new BlockingFirstSubscriber<T>();
            source.Subscribe(s);
            return s.Get(true);
        }

        /// <summary>
        /// Subscribe to the source and block until it produces a value or
        /// signals an Exception. An empty source will throw an IndexOutOfRangeException.
        /// </summary>
        /// <typeparam name="T">The value type</typeparam>
        /// <param name="source">The source</param>
        /// <param name="timeout">The maximum amount of time to wait for the value.</param>
        /// <returns>The value produced</returns>
        /// <exception cref="IndexOutOfRangeException">If the source is empty.</exception>
        /// <exception cref="TimeoutException">If the source didn't produce any value within the given timeout.</exception>
        public static T BlockFirst<T>(this IFlux<T> source, TimeSpan timeout)
        {
            var s = new BlockingFirstSubscriber<T>();
            source.Subscribe(s);
            return s.Get(timeout, true, true);
        }

        /// <summary>
        /// Subscribe to the source and block until it completes and returns the last value produces a value or
        /// signals an Exception. An empty source will throw an IndexOutOfRangeException.
        /// </summary>
        /// <typeparam name="T">The value type</typeparam>
        /// <param name="source">The source</param>
        /// <returns>The value produced</returns>
        /// <exception cref="IndexOutOfRangeException">If the source is empty.</exception>
        public static T BlockLast<T>(this IFlux<T> source)
        {
            var s = new BlockingLastSubscriber<T>();
            source.Subscribe(s);
            return s.Get(true);
        }

        /// <summary>
        /// Subscribe to the source and block until it completes and returns the last value or
        /// signals an Exception. An empty source will throw an IndexOutOfRangeException.
        /// </summary>
        /// <typeparam name="T">The value type</typeparam>
        /// <param name="source">The source</param>
        /// <param name="timeout">The maximum amount of time to wait for the value.</param>
        /// <returns>The value produced</returns>
        /// <exception cref="IndexOutOfRangeException">If the source is empty.</exception>
        /// <exception cref="TimeoutException">If the source didn't produce any value within the given timeout.</exception>
        public static T BlockLast<T>(this IFlux<T> source, TimeSpan timeout)
        {
            var s = new BlockingLastSubscriber<T>();
            source.Subscribe(s);
            return s.Get(timeout, true, true);
        }

        /// <summary>
        /// Subscribes to the IPublisher and ignores all of its signals.
        /// </summary>
        /// <typeparam name="T">The value type</typeparam>
        /// <param name="source">The source IPublisher</param>
        /// <returns>The IDisposable that allows cancelling the subscription.</returns>
        public static IDisposable Subscribe<T>(this IFlux<T> source)
        {
            var d = new CallbackSubscriber<T>(v => { }, e => { ExceptionHelper.OnErrorDropped(e); }, () => { });
            source.Subscribe(d);
            return d;
        }

        /// <summary>
        /// Subscribes to the IPublisher and consumes only its OnNext signals.
        /// </summary>
        /// <typeparam name="T">The value type</typeparam>
        /// <param name="source">The source IPublisher</param>
        /// <param name="onNext">The callback for the OnNext signals</param>
        /// <returns>The IDisposable that allows cancelling the subscription.</returns>
        public static IDisposable Subscribe<T>(this IFlux<T> source, Action<T> onNext)
        {
            var d = new CallbackSubscriber<T>(onNext, e => { ExceptionHelper.OnErrorDropped(e); }, () => { });
            source.Subscribe(d);
            return d;
        }

        /// <summary>
        /// Subscribes to the IPublisher and consumes only its OnNext signals.
        /// </summary>
        /// <remarks>
        /// If the <paramref name="onNext"/> callback crashes, the error is routed
        /// to <paramref name="onError"/> callback.
        /// If the <paramref name="onError"/> callback crashes, the error is routed to the
        /// global error hanlder in <see cref="ExceptionHelper.OnErrorDropped(Exception)"/>.
        /// </remarks>
        /// <typeparam name="T">The value type</typeparam>
        /// <param name="source">The source IPublisher</param>
        /// <param name="onNext">The callback for the OnNext signals</param>
        /// <param name="onError">The callback for the OnError signals</param>
        /// <returns>The IDisposable that allows cancelling the subscription.</returns>
        public static IDisposable Subscribe<T>(this IFlux<T> source, Action<T> onNext, Action<Exception> onError)
        {
            var d = new CallbackSubscriber<T>(onNext, onError, () => { });
            source.Subscribe(d);
            return d;
        }

        /// <summary>
        /// Subscribes to the IPublisher and consumes only its OnNext signals.
        /// </summary>
        /// <remarks>
        /// If the <paramref name="onNext"/> callback crashes, the error is routed
        /// to <paramref name="onError"/> callback.
        /// If the <paramref name="onError"/> or <paramref name="onComplete"/> callbackcrashes, 
        /// the error is routed to the
        /// global error hanlder in <see cref="ExceptionHelper.OnErrorDropped(Exception)"/>.
        /// </remarks>
        /// <typeparam name="T">The value type</typeparam>
        /// <param name="source">The source IPublisher</param>
        /// <param name="onNext">The callback for the OnNext signals.</param>
        /// <param name="onError">The callback for the OnError signal.</param>
        /// <param name="onComplete">The callback for the OnComplete signal.</param>
        /// <returns>The IDisposable that allows cancelling the subscription.</returns>
        public static IDisposable Subscribe<T>(this IFlux<T> source, Action<T> onNext, Action<Exception> onError, Action onComplete)
        {
            var d = new CallbackSubscriber<T>(onNext, onError, onComplete);
            source.Subscribe(d);
            return d;
        }

        public static E SubscribeWith<T, E>(this IFlux<T> source, E subscriber) where E : ISubscriber<T>
        {
            source.Subscribe(subscriber);
            return subscriber;
        }

        public static IEnumerable<T> ToEnumerable<T>(this IFlux<T> source)
        {
            return ToEnumerable(source, BufferSize);
        }

        public static IEnumerable<T> ToEnumerable<T>(this IFlux<T> source, int prefetch)
        {
            return new PublisherAsEnumerable<T>(source, prefetch);
        }

        /// <summary>
        /// Returns a Task that awaits the first item from the IFlux or
        /// signals an IndexOutOfRangeException if the IFlux is empty.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux</param>
        /// <returns>The task.</returns>
        public static Task<T> FirstTask<T>(this IFlux<T> source)
        {
            var s = new TaskFirstSubscriber<T>();
            source.Subscribe(s);
            return s.Task();
        }

        /// <summary>
        /// Returns a Task that awaits the first item from the IFlux or
        /// signals an IndexOutOfRangeException if the IFlux is empty.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux</param>
        /// <param name="ct">The cancellation token.</param>
        /// <returns>The task.</returns>
        public static Task<T> FirstTask<T>(this IFlux<T> source, CancellationToken ct)
        {
            var s = new TaskFirstSubscriber<T>();
            source.Subscribe(s);
            return s.Task(ct);
        }

        /// <summary>
        /// Returns a Task that awaits the last item from the IFlux or
        /// signals an IndexOutOfRangeException if the IFlux is empty.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux</param>
        /// <returns>The task.</returns>
        public static Task<T> LastTask<T>(this IFlux<T> source)
        {
            var s = new TaskLastSubscriber<T>();
            source.Subscribe(s);
            return s.Task();
        }

        /// <summary>
        /// Returns a Task that awaits the last item from the IFlux or
        /// signals an IndexOutOfRangeException if the IFlux is empty.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux</param>
        /// <param name="ct">The cancellation token.</param>
        /// <returns>The task.</returns>
        public static Task<T> LastTask<T>(this IFlux<T> source, CancellationToken ct)
        {
            var s = new TaskLastSubscriber<T>();
            source.Subscribe(s);
            return s.Task(ct);
        }

        /// <summary>
        /// Return a Task that waits for the IMono source to complete.
        /// </summary>
        /// <param name="source">The source IMono</param>
        /// <returns>The task.</returns>
        public static Task WhenCompleteTask<T>(this IFlux<T> source)
        {
            var s = new TaskCompleteSubscriber<T>();
            source.Subscribe(s);
            return s.Task();
        }

        /// <summary>
        /// Return a Task that waits for the IMono source to complete
        /// and support the cancellation of such wait.
        /// </summary>
        /// <param name="source">The source IMono</param>
        /// <param name="ct">The cancellation token.</param>
        /// <returns>The task.</returns>
        public static Task WhenCompleteTask<T>(this IFlux<T> source, CancellationToken ct)
        {
            var s = new TaskCompleteSubscriber<T>();
            source.Subscribe(s);
            return s.Task(ct);
        }

        /// <summary>
        /// Creates a TestSubscriber with the given initial settings and returns it.
        /// </summary>
        /// <typeparam name="T">The value type received.</typeparam>
        /// <param name="source">The source IFlux</param>
        /// <param name="initialRequest">The optional initial request amount.</param>
        /// <param name="fusionMode">The optional fusion mode if supported by the source.</param>
        /// <param name="cancelled">Optionally start out as cancelled.</param>
        /// <returns></returns>
        public static TestSubscriber<T> Test<T>(this IFlux<T> source, long initialRequest = long.MaxValue, int fusionMode = 0, bool cancelled = false)
        {
            TestSubscriber<T> ts = new TestSubscriber<T>(initialRequest, fusionMode);
            if (cancelled)
            {
                ts.Cancel();
            }

            source.Subscribe(ts);

            return ts;
        }

        /// <summary>
        /// Convenience method to signal the given values to the IProcessor.
        /// </summary>
        /// <typeparam name="T">The input value type.</typeparam>
        /// <typeparam name="U">The output value type</typeparam>
        /// <param name="processor">The target processor instance.</param>
        /// <param name="t1">The first value to signal.</param>
        /// <param name="t2">The second value to signal.</param>
        /// <param name="values">The rest of the values to signal.</param>
        public static void OnNext<T, U>(this IProcessor<T, U> processor, T t1, T t2, params T[] values)
        {
            processor.OnNext(t1);
            processor.OnNext(t2);
            foreach (var t in values)
            {
                processor.OnNext(t);
            }
        }
    }
}
